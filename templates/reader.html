<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: #fff; }
        body.sidebar-collapsed #sidebar { width: 0; padding: 0; border-right: none; transform: translateX(-100%); opacity: 0; pointer-events: none; }
        body.sidebar-collapsed #main { width: 100%; }
        body.selection-mode .book-content { cursor: text; user-select: text; }
        body.selection-mode .book-content ::selection { background: #ffeb3b; color: #000; }
        
        /* PDF-specific styles */
        body.is-pdf .book-content { user-select: text; cursor: text; }
        body.is-pdf .book-content ::selection { background: #b3d9ff; color: #000; }

        /* Sidebar */
        #sidebar { width: 300px; background: #f8f9fa; border-right: 1px solid #e9ecef; overflow-y: auto; padding: 20px; flex-shrink: 0; transition: width 0.2s ease, transform 0.2s ease, opacity 0.2s ease; }
        .nav-header { font-family: -apple-system, sans-serif; font-weight: bold; color: #495057; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6; }
        .nav-home { display: block; margin-bottom: 20px; margin-top: 45px; color: #3498db; text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.9em; }

        #sidebar-toggle { position: fixed; top: 15px; left: 15px; z-index: 1000; border: 1px solid #ddd; background: rgba(255, 255, 255, 0.95); color: #495057; padding: 8px 14px; border-radius: 5px; font-family: -apple-system, sans-serif; font-size: 0.85em; font-weight: 500; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); }
        #sidebar-toggle:hover { background: #495057; color: #fff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); }

        /* Selection floating toolbar */
        #selection-toolbar { display: none; position: fixed; z-index: 1001; background: #333; color: #fff; padding: 8px 12px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); font-family: -apple-system, sans-serif; font-size: 0.85em; }
        #selection-toolbar.visible { display: flex; gap: 8px; align-items: center; }
        #selection-toolbar button { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #fff; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.85em; transition: all 0.2s; }
        #selection-toolbar button:hover { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.5); }
        #selection-toolbar .selection-count { opacity: 0.7; font-size: 0.8em; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: #495057; font-size: 0.95em; display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; line-height: 1.4; border-radius: 4px; transition: all 0.2s ease; border-left: 3px solid transparent; margin-left: -3px; position: relative; }
        a.toc-link:hover { color: #000; background-color: #f1f3f5; border-left-color: #d63384; }
        a.toc-link.active { color: #fff; font-weight: 600; background: linear-gradient(135deg, #d63384 0%, #c21f6b 100%); box-shadow: 0 2px 6px rgba(214, 51, 132, 0.35); border-left-color: #fff; }
        a.toc-link.unread { background-color: rgba(150, 150, 150, 0.08); opacity: 0.75; }
        .toc-chapter-percent { font-size: 0.8em; color: #888; font-weight: normal; flex-shrink: 0; margin-left: 8px; }

        /* Multi-chapter copy controls */
        .multi-copy-controls { padding: 10px 15px; border-bottom: 1px solid #eee; background: #f8f9fa; }
        .multi-copy-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .multi-copy-title { font-size: 0.85em; font-weight: 600; color: #495057; }
        .multi-copy-actions { display: flex; gap: 6px; }
        .multi-copy-btn { padding: 4px 10px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.75em; transition: all 0.2s; }
        .multi-copy-btn:hover { background: #495057; color: #fff; }
        .chapter-filter { display: flex; gap: 8px; margin-bottom: 10px; }
        .chapter-filter select, .chapter-filter input { padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.8em; flex: 1; }
        .chapter-filter select { flex: 0 0 40%; background: #fff; }
        .chapter-filter input::placeholder { color: #aaa; }
        .copy-selected-btn { padding: 8px 16px; background: #3498db; color: #fff; border: 1px solid #3498db; border-radius: 5px; cursor: pointer; font-size: 0.85em; font-weight: 500; transition: all 0.2s; width: 100%; }
        .copy-selected-btn:hover { background: #2980b9; box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3); }
        .copy-selected-btn:disabled { background: #ccc; border-color: #ccc; cursor: not-allowed; opacity: 0.6; }
        .chapter-checkbox { margin-right: 8px; cursor: pointer; width: 16px; height: 16px; }
        
        /* Chapter progress indicator */
        .toc-item-wrapper { position: relative; }
        .chapter-progress { display: flex; align-items: center; gap: 8px; padding: 2px 12px 8px; }
        .chapter-progress-bar { flex: 1; height: 3px; background: #e9ecef; border-radius: 2px; overflow: hidden; }
        .chapter-progress-fill { height: 100%; background: linear-gradient(90deg, #3498db, #9b59b6); transition: width 0.3s; }
        .chapter-reading-time { font-size: 0.75em; color: #666; white-space: nowrap; background: #f0f0f0; padding: 2px 6px; border-radius: 10px; }
        a.toc-link.read { position: relative; }
        a.toc-link.read::after { content: '✓'; position: absolute; right: 10px; top: 50%; transform: translateY(-50%); font-size: 0.8em; color: #27ae60; }
        a.toc-link.active::after { color: rgba(255,255,255,0.8); }
        
        /* Empty state illustrations */
        .empty-state { text-align: center; padding: 40px 20px; }
        .empty-state-icon { font-size: 4em; margin-bottom: 15px; opacity: 0.5; }
        .empty-state-text { color: #888; font-size: 0.95em; margin-bottom: 10px; }
        .empty-state-hint { color: #aaa; font-size: 0.85em; }
        
        /* Keyboard shortcuts help */
        #keyboard-help { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); color: #fff; padding: 15px 20px; border-radius: 10px; font-family: -apple-system, sans-serif; font-size: 0.85em; z-index: 1000; opacity: 0; transform: translateY(20px); transition: all 0.3s ease; pointer-events: none; }
        #keyboard-help.visible { opacity: 1; transform: translateY(0); }
        .kbd { display: inline-block; background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 4px; margin: 0 2px; font-family: monospace; }
        .shortcut-row { display: flex; justify-content: space-between; gap: 20px; margin: 5px 0; }
        .shortcut-key { opacity: 0.7; }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px 60px 40px; line-height: 1.8; font-size: 1.15em; color: #212529; background: #fff; position: relative; z-index: 1; }
        .content-toolbar { display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 25px; font-family: -apple-system, sans-serif; flex-wrap: wrap; }
        .content-toolbar.pdf-toolbar { position: sticky; top: 0; background: #fff; padding: 15px 10px 15px 10px; margin: -15px -10px 25px -10px; z-index: 50; border-radius: 0 0 8px 8px; transition: box-shadow 0.3s ease; }
        .content-toolbar.pdf-toolbar.stuck { box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .toolbar-btn { border: 1px solid #ddd; background: #fff; color: #495057; padding: 9px 16px; border-radius: 5px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: all 0.2s ease; }
        .toolbar-btn:hover { background: #495057; color: #fff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        .toolbar-btn:active { transform: scale(0.97); }
        .toolbar-btn.active { background: #3498db; color: #fff; border-color: #3498db; }
#copy-status { font-family: -apple-system, sans-serif; font-size: 0.85em; color: #198754; text-align: right; min-height: 1.2em; opacity: 0; transition: opacity 0.3s ease-in-out; font-weight: 500; }
        
        /* Reading momentum toolbar */
        .reading-momentum { display: flex; align-items: center; gap: 15px; margin-right: auto; font-family: -apple-system, sans-serif; }
        .momentum-item { display: flex; align-items: center; gap: 6px; font-size: 0.9em; color: #666; }
        .momentum-icon { font-size: 1.1em; }
        .reading-time-counter { font-weight: 500; color: #333; min-width: 60px; text-align: right; }
        .streak-indicator { display: inline-flex; align-items: center; gap: 4px; background: linear-gradient(135deg, #ffa500, #ff6b6b); color: #fff; padding: 4px 10px; border-radius: 20px; font-size: 0.8em; font-weight: 600; }
        
        /* Fade transition for chapter changes */
        .content-container.fade-out { opacity: 0; transition: opacity 0.3s ease; }
        .content-container.fade-in { opacity: 1; transition: opacity 0.3s ease; }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content { position: relative; z-index: 1; }
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: #333; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; }

        /* Navigation Footer */
        .chapter-nav { position: relative; z-index: 10; display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; padding-bottom: 20px; border-top: 1px solid #eee; background: #fff; font-family: -apple-system, sans-serif; }
        .nav-btn { text-decoration: none; color: #3498db; font-weight: 600; padding: 12px 22px; border: 1px solid #3498db; border-radius: 5px; transition: all 0.2s ease; }
        .nav-btn:hover { background: #3498db; color: white; box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3); }
        .nav-btn:active { transform: scale(0.96); }
        .nav-btn.disabled { opacity: 0.4; pointer-events: none; border-color: #ddd; color: #bbb; }

        /* PDF Page styling */
        .pdf-page { position: relative; padding: 30px 0; border-bottom: 1px solid #eee; margin-bottom: 30px; }
        .pdf-page:last-child { border-bottom: none; }
        .pdf-page-header { color: #999; font-size: 0.85em; margin-bottom: 20px; font-family: -apple-system, sans-serif; position: sticky; top: 0; background: linear-gradient(to bottom, #fff 70%, transparent); padding: 10px 160px 20px 10px; z-index: 5; display: flex; align-items: center; justify-content: center; }
        .pdf-page-number { display: inline-block; background: #f0f0f0; padding: 4px 12px; border-radius: 12px; font-size: 0.8em; }
        .pdf-page-actions { position: absolute; right: 10px; top: 50%; transform: translateY(-50%); display: flex; gap: 8px; flex-wrap: wrap; }
        
        /* PDF page image container - renders page like traditional PDF viewer */
        .pdf-page-image-container { text-align: center; margin: 20px 0; }
        .pdf-page-image { max-width: 100%; height: auto; box-shadow: 0 2px 12px rgba(0,0,0,0.15); border-radius: 2px; background: #fff; }
        
        /* PDF copy page button */
        .pdf-copy-image-btn { display: inline-flex; align-items: center; gap: 6px; background: #f8f9fa; border: 1px solid #ddd; color: #495057; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-family: -apple-system, sans-serif; font-size: 0.8em; transition: all 0.2s; }
        .pdf-copy-image-btn:hover { background: #495057; color: #fff; }
        .pdf-copy-image-btn.copied { background: #27ae60; color: #fff; border-color: #27ae60; }
        
        /* PDF page selection checkbox */
        .pdf-page-select { width: 18px; height: 18px; cursor: pointer; accent-color: #3498db; margin-right: 8px; }
        .pdf-page.selected { outline: 3px solid #3498db; outline-offset: -3px; }
        .pdf-multi-copy-btn { display: none; background: #3498db; color: #fff; border: none; }
        .pdf-multi-copy-btn:hover { background: #2980b9; }
        .pdf-multi-copy-btn.visible { display: inline-flex; }
        .pdf-clear-btn { display: none; background: #e74c3c; color: #fff; border: none; }
        .pdf-clear-btn:hover { background: #c0392b; }
        .pdf-clear-btn.visible { display: inline-flex; }
        
        /* PDF floating page indicator */
        #pdf-page-indicator { position: fixed; bottom: 30px; right: 30px; background: rgba(0,0,0,0.8); color: #fff; padding: 10px 18px; border-radius: 25px; font-family: -apple-system, sans-serif; font-size: 0.9em; z-index: 100; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        #pdf-page-indicator.visible { opacity: 1; }
        
        /* PDF progress bar */
        #pdf-progress { position: fixed; top: 0; left: 0; height: 3px; background: linear-gradient(90deg, #3498db, #9b59b6); z-index: 1001; transition: width 0.3s ease; }
        
        /* Quick page jump for PDFs */
        #page-jump-container { display: none; position: fixed; bottom: 80px; right: 30px; background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; font-family: -apple-system, sans-serif; }
        #page-jump-container.visible { display: block; }
        #page-jump-input { width: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; text-align: center; font-size: 1em; }
        #page-jump-btn { background: #3498db; color: #fff; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 8px; }
        #page-jump-btn:hover { background: #2980b9; }
        
        /* Copy toast notification */
        #copy-toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(100px); background: #333; color: #fff; padding: 12px 24px; border-radius: 8px; font-family: -apple-system, sans-serif; font-size: 0.9em; z-index: 1002; opacity: 0; transition: all 0.3s ease; }
        #copy-toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
        #copy-toast.success { background: #27ae60; }
        #copy-toast.error { background: #e74c3c; }
        #copy-toast.info { background: #3498db; }

        /* Highlights */
        .highlight-yellow { background-color: rgba(255, 235, 59, 0.4); }
        .highlight-green { background-color: rgba(76, 175, 80, 0.3); }
        .highlight-blue { background-color: rgba(33, 150, 243, 0.3); }
        .highlight-pink { background-color: rgba(233, 30, 99, 0.3); }
        .highlight-purple { background-color: rgba(156, 39, 176, 0.3); }
        .highlight-mark { cursor: pointer; border-radius: 2px; transition: all 0.2s; }
        .highlight-mark:hover { filter: brightness(0.9); }
        
        /* Highlight color picker in toolbar */
        .highlight-colors { display: flex; gap: 4px; align-items: center; }
        #selection-toolbar .highlight-color-btn { width: 20px; height: 20px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.5); cursor: pointer; transition: all 0.2s; padding: 0; }
        #selection-toolbar .highlight-color-btn:hover { transform: scale(1.2); border-color: #fff; }
        #selection-toolbar .highlight-color-btn.yellow { background: #ffeb3b; }
        #selection-toolbar .highlight-color-btn.green { background: #4caf50; }
        #selection-toolbar .highlight-color-btn.blue { background: #2196f3; }
        #selection-toolbar .highlight-color-btn.pink { background: #e91e63; }
        #selection-toolbar .highlight-color-btn.purple { background: #9c27b0; }
        
        /* Bookmarks panel */
        #bookmarks-panel { position: fixed; top: 60px; right: -350px; width: 320px; height: calc(100vh - 80px); background: #fff; border-left: 1px solid #ddd; box-shadow: -4px 0 12px rgba(0,0,0,0.1); z-index: 999; transition: right 0.3s ease; overflow-y: auto; padding: 20px; font-family: -apple-system, sans-serif; }
        #bookmarks-panel.visible { right: 0; }
        .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .panel-title { font-size: 1.1em; font-weight: 600; color: #333; }
        .panel-close { background: none; border: none; font-size: 1.5em; cursor: pointer; color: #999; }
        .panel-tabs { display: flex; gap: 10px; margin-bottom: 15px; }
        .panel-tab { padding: 8px 16px; border: none; background: #f0f0f0; border-radius: 20px; cursor: pointer; font-size: 0.85em; transition: all 0.2s; }
        .panel-tab.active { background: #3498db; color: #fff; }
        .bookmark-item, .highlight-item { padding: 12px; background: #f9f9f9; border-radius: 6px; margin-bottom: 10px; position: relative; }
        .bookmark-item:hover, .highlight-item:hover { background: #f0f0f0; }
        .bookmark-title { font-weight: 500; color: #333; margin-bottom: 4px; cursor: pointer; }
        .bookmark-meta { font-size: 0.8em; color: #888; }
        .bookmark-note { font-size: 0.85em; color: #666; margin-top: 6px; font-style: italic; }
        .bookmark-actions { position: absolute; top: 8px; right: 8px; display: flex; gap: 4px; }
        .bookmark-action-btn { background: none; border: none; cursor: pointer; font-size: 0.9em; opacity: 0.6; }
        .bookmark-action-btn:hover { opacity: 1; }
        .highlight-text { font-size: 0.9em; color: #555; margin-bottom: 6px; padding: 8px; border-radius: 4px; }
        
        /* Search modal */
        #search-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1100; }
        #search-modal.visible { display: flex; justify-content: center; align-items: flex-start; padding-top: 80px; }
        .search-container { background: #fff; width: 600px; max-width: 90%; max-height: 80vh; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); overflow: hidden; }
        .search-header { padding: 20px; border-bottom: 1px solid #eee; }
        .search-input-wrapper { display: flex; gap: 10px; }
        .search-input { flex: 1; padding: 12px 16px; border: 2px solid #ddd; border-radius: 8px; font-size: 1em; outline: none; transition: border-color 0.2s; }
        .search-input:focus { border-color: #3498db; }
        .search-btn { background: #3498db; color: #fff; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; }
        .search-btn:hover { background: #2980b9; }
        .search-results { max-height: 60vh; overflow-y: auto; padding: 10px 20px 20px; }
        .search-result { padding: 15px; border-bottom: 1px solid #eee; cursor: pointer; transition: background 0.2s; }
        .search-result:hover { background: #f5f5f5; }
        .search-result-title { font-weight: 500; color: #333; margin-bottom: 4px; }
        .search-result-chapter { font-size: 0.85em; color: #888; margin-bottom: 6px; }
        .search-result-context { font-size: 0.9em; color: #555; }
        .search-result-context mark { background: #ffeb3b; padding: 0 2px; border-radius: 2px; }
        .search-history { padding: 10px 0; }
        .search-history-title { font-size: 0.85em; color: #888; margin-bottom: 10px; }
        .search-history-item { display: inline-block; padding: 6px 12px; background: #f0f0f0; border-radius: 20px; margin: 4px; cursor: pointer; font-size: 0.85em; }
        .search-history-item:hover { background: #e0e0e0; }
        
        /* Reading progress indicator */
        #reading-progress { position: fixed; top: 0; left: 0; width: 100%; height: 3px; background: #e0e0e0; z-index: 1000; }
        #reading-progress-bar { height: 100%; background: linear-gradient(90deg, #3498db, #9b59b6); transition: width 0.1s; width: 0%; }
        
        /* Resume reading banner */
        #resume-banner { display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #fff; padding: 15px 25px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 100; font-family: -apple-system, sans-serif; }
        #resume-banner.visible { display: flex; align-items: center; gap: 15px; }
        .resume-text { font-size: 0.9em; color: #555; }
        .resume-btn { background: #3498db; color: #fff; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 0.85em; }
        .resume-dismiss { background: none; border: none; color: #999; cursor: pointer; font-size: 1.2em; }
        
        /* Dictionary/Definition popup */
        #dictionary-popup { display: none; position: fixed; z-index: 1200; background: #fff; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.25); min-width: 320px; max-width: 420px; font-family: -apple-system, sans-serif; overflow: hidden; left: 50%; top: 50%; transform: translate(-50%, -50%) scale(0.95); opacity: 0; transition: transform 0.2s ease, opacity 0.2s ease; }
        #dictionary-popup.visible { display: block; transform: translate(-50%, -50%) scale(1); opacity: 1; }
        .dict-header { background: #f8f9fa; padding: 15px 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        .dict-word { font-size: 1.3em; font-weight: 600; color: #333; }
        .dict-phonetic { font-size: 0.9em; color: #888; margin-left: 10px; font-style: italic; }
        .dict-close { background: none; border: none; font-size: 1.5em; cursor: pointer; color: #999; line-height: 1; }
        .dict-close:hover { color: #333; }
        .dict-content { padding: 20px; max-height: 300px; overflow-y: auto; }
        .dict-part-of-speech { font-size: 0.85em; color: #3498db; font-weight: 500; text-transform: italic; margin-bottom: 8px; }
        .dict-definition { font-size: 0.95em; color: #333; line-height: 1.6; margin-bottom: 12px; }
        .dict-example { font-size: 0.9em; color: #666; font-style: italic; padding: 10px 15px; background: #f8f9fa; border-radius: 6px; margin-bottom: 15px; border-left: 3px solid #3498db; }
        .dict-actions { display: flex; gap: 10px; padding-top: 15px; border-top: 1px solid #eee; margin-top: 10px; }
        .dict-btn { flex: 1; padding: 10px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9em; transition: all 0.2s; }
        .dict-btn-primary { background: #3498db; color: #fff; }
        .dict-btn-primary:hover { background: #2980b9; }
        .dict-btn-secondary { background: #f0f0f0; color: #555; }
        .dict-btn-secondary:hover { background: #e0e0e0; }
        .dict-loading { text-align: center; padding: 30px; color: #888; }
        .dict-error { text-align: center; padding: 30px; color: #e74c3c; }
        
        /* Vocabulary panel */
        #vocabulary-panel { position: fixed; top: 60px; right: -400px; width: 380px; height: calc(100vh - 80px); background: #fff; border-left: 1px solid #ddd; box-shadow: -4px 0 12px rgba(0,0,0,0.1); z-index: 999; transition: right 0.3s ease; overflow: hidden; font-family: -apple-system, sans-serif; display: flex; flex-direction: column; }
        #vocabulary-panel.visible { right: 0; }
        .vocab-header { padding: 20px; border-bottom: 1px solid #eee; }
        .vocab-search { width: 100%; padding: 10px 15px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; margin-top: 10px; }
        .vocab-list { flex: 1; overflow-y: auto; padding: 10px 20px; }
        .vocab-item { padding: 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 10px; position: relative; }
        .vocab-word { font-weight: 600; color: #333; font-size: 1.1em; }
        .vocab-pos { font-size: 0.8em; color: #3498db; margin-left: 8px; font-style: italic; }
        .vocab-def { font-size: 0.9em; color: #555; margin-top: 6px; line-height: 1.5; }
        .vocab-context { font-size: 0.85em; color: #888; font-style: italic; margin-top: 8px; padding: 8px; background: #fff; border-radius: 4px; }
        .vocab-meta { font-size: 0.75em; color: #aaa; margin-top: 8px; }
        .vocab-delete { position: absolute; top: 10px; right: 10px; background: none; border: none; cursor: pointer; font-size: 0.9em; opacity: 0.5; }
        .vocab-delete:hover { opacity: 1; }
        .vocab-stats { padding: 15px 20px; background: #f8f9fa; border-top: 1px solid #eee; font-size: 0.85em; color: #666; }
        
        /* Annotations panel */
        #annotations-panel { position: fixed; top: 60px; right: -400px; width: 380px; height: calc(100vh - 80px); background: #fff; border-left: 1px solid #ddd; box-shadow: -4px 0 12px rgba(0,0,0,0.1); z-index: 999; transition: right 0.3s ease; overflow: hidden; font-family: -apple-system, sans-serif; display: flex; flex-direction: column; }
        #annotations-panel.visible { right: 0; }
        .annot-header { padding: 20px; border-bottom: 1px solid #eee; }
        .annot-tabs { display: flex; gap: 10px; margin-top: 15px; }
        .annot-tab { flex: 1; padding: 8px; border: none; background: #f0f0f0; border-radius: 6px; cursor: pointer; font-size: 0.85em; transition: all 0.2s; }
        .annot-tab.active { background: #3498db; color: #fff; }
        .annot-search { width: 100%; padding: 10px 15px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; margin-top: 10px; }
        .annot-list { flex: 1; overflow-y: auto; padding: 10px 20px; }
        .annot-item { padding: 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 10px; position: relative; }
        .annot-chapter { font-size: 0.8em; color: #3498db; font-weight: 500; margin-bottom: 6px; }
        .annot-text { font-size: 0.95em; color: #333; line-height: 1.5; }
        .annot-tags { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 10px; }
        .annot-tag { font-size: 0.75em; background: #e8f4fc; color: #3498db; padding: 3px 8px; border-radius: 12px; }
        .annot-meta { font-size: 0.75em; color: #aaa; margin-top: 8px; }
        .annot-actions { position: absolute; top: 10px; right: 10px; display: flex; gap: 6px; }
        .annot-actions button { background: none; border: none; cursor: pointer; font-size: 0.85em; opacity: 0.5; }
        .annot-actions button:hover { opacity: 1; }
        .annot-export { padding: 15px 20px; background: #f8f9fa; border-top: 1px solid #eee; }
        .annot-export-btn { width: 100%; padding: 10px; background: #27ae60; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9em; }
        .annot-export-btn:hover { background: #219a52; }
        
        /* Add note modal */
        #add-note-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1150; justify-content: center; align-items: center; }
        #add-note-modal.visible { display: flex; }
        .note-modal-content { background: #fff; width: 500px; max-width: 90%; border-radius: 12px; overflow: hidden; }
        .note-modal-header { padding: 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        .note-modal-header h3 { margin: 0; font-size: 1.1em; color: #333; }
        .note-modal-body { padding: 20px; }
        .note-textarea { width: 100%; height: 150px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; font-size: 0.95em; resize: vertical; font-family: inherit; }
        .note-tags-input { width: 100%; padding: 10px 15px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; margin-top: 15px; }
        .note-modal-footer { padding: 15px 20px; border-top: 1px solid #eee; display: flex; justify-content: flex-end; gap: 10px; }
        
        /* Session history panel */
        #session-history-panel { position: fixed; top: 60px; right: -400px; width: 380px; height: calc(100vh - 80px); background: #fff; border-left: 1px solid #ddd; box-shadow: -4px 0 12px rgba(0,0,0,0.1); z-index: 999; transition: right 0.3s ease; overflow: hidden; font-family: -apple-system, sans-serif; display: flex; flex-direction: column; }
        #session-history-panel.visible { right: 0; }
        .session-stats { padding: 20px; background: linear-gradient(135deg, #3498db, #9b59b6); color: #fff; }
        .session-stats-title { font-size: 0.85em; opacity: 0.9; margin-bottom: 10px; }
        .session-stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .stat-item { text-align: center; }
        .stat-value { font-size: 1.5em; font-weight: 600; }
        .stat-label { font-size: 0.75em; opacity: 0.8; }
        .session-list { flex: 1; overflow-y: auto; padding: 10px 20px; }
        .session-item { padding: 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s; }
        .session-item:hover { background: #f0f0f0; transform: translateX(5px); }
        .session-book { font-weight: 500; color: #333; margin-bottom: 4px; }
        .session-chapter { font-size: 0.85em; color: #666; }
        .session-time { font-size: 0.8em; color: #888; margin-top: 8px; display: flex; justify-content: space-between; }
        
        /* Lazy load placeholder for images */
        .lazy-image { background: #f0f0f0; min-height: 200px; display: flex; align-items: center; justify-content: center; color: #999; }
        .lazy-image.loaded { min-height: auto; background: none; }

        /* Highlight context menu */
        #highlight-context-menu { display: none; position: fixed; z-index: 1100; background: #fff; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.2); font-family: -apple-system, sans-serif; min-width: 160px; overflow: hidden; }
        #highlight-context-menu.visible { display: block; }
        .highlight-menu-item { padding: 10px 16px; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 0.9em; transition: background 0.2s; }
        .highlight-menu-item:hover { background: #f5f5f5; }
        .highlight-menu-item.delete { color: #e74c3c; }
        .highlight-menu-item.delete:hover { background: #fdf2f2; }
        .highlight-menu-colors { display: flex; gap: 6px; padding: 10px 16px; border-bottom: 1px solid #eee; }
        .highlight-menu-color { width: 24px; height: 24px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.2s; }
        .highlight-menu-color:hover { transform: scale(1.15); }
        .highlight-menu-color.active { border-color: #333; }
        .highlight-menu-color.yellow { background: #ffeb3b; }
        .highlight-menu-color.green { background: #4caf50; }
        .highlight-menu-color.blue { background: #2196f3; }
        .highlight-menu-color.pink { background: #e91e63; }
        .highlight-menu-color.purple { background: #9c27b0; }

        /* Inline copy buttons next to headings */
        .heading-copy-btn { margin-left: 8px; display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 6px; background: #f8f9fa; color: #444; font-size: 0.8em; cursor: pointer; transition: all 0.15s; }
        .heading-copy-btn:hover { background: #eef2ff; border-color: #d0d7ff; color: #2c3e50; }

    </style>
</head>
<body class="{{ 'is-pdf' if is_pdf else '' }}">

    <!-- Reading progress bar at top -->
    <div id="reading-progress">
        <div id="reading-progress-bar"></div>
    </div>

    <!-- PDF progress bar -->
    {% if is_pdf %}
    <div id="pdf-progress" style="width: 0%"></div>
    {% endif %}

    <button id="sidebar-toggle" type="button" onclick="toggleSidebar()" aria-pressed="false" aria-controls="sidebar">Hide Chapters</button>

    <!-- Selection floating toolbar -->
    <div id="selection-toolbar">
        <span class="selection-count" id="selection-char-count"></span>
        <div class="highlight-colors">
            <button class="highlight-color-btn yellow" onclick="highlightSelection('yellow')" title="Highlight yellow"></button>
            <button class="highlight-color-btn green" onclick="highlightSelection('green')" title="Highlight green"></button>
            <button class="highlight-color-btn blue" onclick="highlightSelection('blue')" title="Highlight blue"></button>
            <button class="highlight-color-btn pink" onclick="highlightSelection('pink')" title="Highlight pink"></button>
            <button class="highlight-color-btn purple" onclick="highlightSelection('purple')" title="Highlight purple"></button>
        </div>
        <button onclick="addBookmark()" title="Bookmark this passage"><i class="fa-regular fa-bookmark"></i> Bookmark</button>
        <button onclick="openAddNoteModal()" title="Add a note"><i class="fa-regular fa-note-sticky"></i> Note</button>
        <button onclick="copySelectedText()" title="Copy selected text"><i class="fa-regular fa-copy"></i> Copy</button>
        <button onclick="appendToClipboard()" title="Add to existing clipboard"><i class="fa-solid fa-plus"></i> Add to Batch</button>
        <button onclick="clearSelection()" title="Clear selection"><i class="fa-solid fa-xmark"></i></button>
    </div>
    
    <!-- Copy toast notification -->
    <div id="copy-toast"></div>
    
    <!-- Highlight context menu -->
    <div id="highlight-context-menu">
        <div class="highlight-menu-colors">
            <div class="highlight-menu-color yellow" onclick="changeHighlightColor('yellow')" title="Yellow"></div>
            <div class="highlight-menu-color green" onclick="changeHighlightColor('green')" title="Green"></div>
            <div class="highlight-menu-color blue" onclick="changeHighlightColor('blue')" title="Blue"></div>
            <div class="highlight-menu-color pink" onclick="changeHighlightColor('pink')" title="Pink"></div>
            <div class="highlight-menu-color purple" onclick="changeHighlightColor('purple')" title="Purple"></div>
        </div>
        <div class="highlight-menu-item" onclick="copyHighlightText()"><i class="fa-regular fa-copy"></i> Copy text</div>
        <div class="highlight-menu-item delete" onclick="deleteCurrentHighlight()"><i class="fa-regular fa-trash-can"></i> Delete highlight</div>
    </div>
    
    <!-- Keyboard shortcuts help -->
    <div id="keyboard-help">
        <div style="font-weight: 600; margin-bottom: 10px;"><i class="fa-regular fa-keyboard"></i> Keyboard Shortcuts</div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">←</span> <span class="kbd">→</span></span><span>Prev/Next chapter</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">⌘/Ctrl</span>+<span class="kbd">F</span></span><span>Search</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">⌘/Ctrl</span>+<span class="kbd">B</span></span><span>Bookmarks</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">⌘/Ctrl</span>+<span class="kbd">Shift</span>+<span class="kbd">B</span></span><span>Add selection to batch</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">Esc</span></span><span>Close modals</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">?</span></span><span>Show/hide this help</span></div>
    </div>
    
    <!-- Resume reading banner -->
    <div id="resume-banner">
        <span class="resume-text">Continue reading from where you left off?</span>
        <button class="resume-btn" onclick="resumeReading()">Resume</button>
        <button class="resume-dismiss" onclick="dismissResume()"><i class="fa-solid fa-xmark"></i></button>
    </div>
    
    <!-- Bookmarks/Highlights Panel -->
    <div id="bookmarks-panel">
        <div class="panel-header">
            <span class="panel-title"><i class="fa-solid fa-book-bookmark"></i> Your Notes</span>
            <button class="panel-close" onclick="toggleBookmarksPanel()"><i class="fa-solid fa-xmark"></i></button>
        </div>
        <div class="panel-tabs">
            <button class="panel-tab active" onclick="showPanelTab('bookmarks')">Bookmarks</button>
            <button class="panel-tab" onclick="showPanelTab('highlights')">Highlights</button>
        </div>
        <div id="bookmarks-list"></div>
        <div id="highlights-list" style="display:none;"></div>
        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
            <button onclick="exportNotes('json')" style="padding: 8px 16px; margin-right: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer;">Export JSON</button>
            <button onclick="exportNotes('markdown')" style="padding: 8px 16px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer;">Export Markdown</button>
        </div>
    </div>
    
    <!-- Search Modal -->
    <div id="search-modal">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-wrapper">
                    <input type="text" class="search-input" id="search-input" placeholder="Search in this book..." onkeydown="if(event.key==='Enter')performSearch()">
                    <button class="search-btn" onclick="performSearch()"><i class="fa-solid fa-magnifying-glass"></i> Search</button>
                </div>
            </div>
            <div class="search-results" id="search-results">
                <div class="search-history" id="search-history"></div>
            </div>
        </div>
    </div>
    
    <!-- Dictionary Popup -->
    <div id="dictionary-popup">
        <div class="dict-header">
            <div>
                <span class="dict-word" id="dict-word"></span>
                <span class="dict-phonetic" id="dict-phonetic"></span>
            </div>
            <button class="dict-close" onclick="closeDictionary()"><i class="fa-solid fa-xmark"></i></button>
        </div>
        <div class="dict-content" id="dict-content">
            <div class="dict-loading">Loading definition...</div>
        </div>
    </div>
    
    <!-- Vocabulary Panel -->
    <div id="vocabulary-panel">
        <div class="vocab-header">
            <div class="panel-header" style="padding: 0; border: none;">
                <span class="panel-title"><i class="fa-solid fa-language"></i> Vocabulary</span>
                <button class="panel-close" onclick="toggleVocabularyPanel()"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <input type="text" class="vocab-search" id="vocab-search" placeholder="Search saved words..." oninput="filterVocabulary()">
        </div>
        <div class="vocab-list" id="vocab-list">
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fa-solid fa-language" style="font-size: 2em; color: #ccc;"></i></div>
                <div class="empty-state-text">No saved words yet</div>
                <div class="empty-state-hint">Double-click any word to look it up and save it</div>
            </div>
        </div>
        <div class="vocab-stats" id="vocab-stats">
            <strong>0</strong> words saved
        </div>
    </div>
    
    <!-- Annotations Panel -->
    <div id="annotations-panel">
        <div class="annot-header">
            <div class="panel-header" style="padding: 0; border: none;">
                <span class="panel-title"><i class="fa-regular fa-note-sticky"></i> Annotations</span>
                <button class="panel-close" onclick="toggleAnnotationsPanel()"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div class="annot-tabs">
                <button class="annot-tab active" onclick="showAnnotTab('all')">All</button>
                <button class="annot-tab" onclick="showAnnotTab('chapter')">This Chapter</button>
                <button class="annot-tab" onclick="showAnnotTab('tags')">By Tag</button>
            </div>
            <input type="text" class="annot-search" id="annot-search" placeholder="Search notes..." oninput="filterAnnotations()">
        </div>
        <div class="annot-list" id="annot-list">
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fa-regular fa-note-sticky" style="font-size: 2em; color: #ccc;"></i></div>
                <div class="empty-state-text">No annotations yet</div>
                <div class="empty-state-hint">Add notes to your highlights and bookmarks</div>
            </div>
        </div>
        <div class="annot-export">
            <button class="annot-export-btn" onclick="exportAnnotations()"><i class="fa-solid fa-file-export"></i> Export Annotations</button>
        </div>
    </div>
    
    <!-- Session History Panel -->
    <div id="session-history-panel">
        <div class="session-stats" id="session-stats">
            <div class="session-stats-title"><i class="fa-solid fa-chart-simple"></i> Your Reading Stats</div>
            <div class="session-stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="stat-total-time">0h</div>
                    <div class="stat-label">Total Reading</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-streak">0</div>
                    <div class="stat-label">Day Streak <i class="fa-solid fa-fire" style="color: #f39c12;"></i></div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-sessions">0</div>
                    <div class="stat-label">Sessions</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-pages">0</div>
                    <div class="stat-label">Pages Read</div>
                </div>
            </div>
        </div>
        <div class="panel-header">
            <span class="panel-title"><i class="fa-solid fa-clock-rotate-left"></i> Reading History</span>
            <button class="panel-close" onclick="toggleSessionPanel()"><i class="fa-solid fa-xmark"></i></button>
        </div>
        <div class="session-list" id="session-list">
            <div class="empty-state">
                <div class="empty-state-icon"><i class="fa-solid fa-clock-rotate-left" style="font-size: 2em; color: #ccc;"></i></div>
                <div class="empty-state-text">No reading sessions yet</div>
                <div class="empty-state-hint">Your reading history will appear here</div>
            </div>
        </div>
    </div>
    
    <!-- Add Note Modal -->
    <div id="add-note-modal">
        <div class="note-modal-content">
            <div class="note-modal-header">
                <h3><i class="fa-regular fa-note-sticky"></i> Add Note</h3>
                <button class="panel-close" onclick="closeNoteModal()"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div class="note-modal-body">
                <textarea class="note-textarea" id="note-textarea" placeholder="Write your note here..."></textarea>
                <input type="text" class="note-tags-input" id="note-tags-input" placeholder="Tags (comma-separated)">
            </div>
            <div class="note-modal-footer">
                <button class="dict-btn dict-btn-secondary" onclick="closeNoteModal()">Cancel</button>
                <button class="dict-btn dict-btn-primary" onclick="saveNote()">Save Note</button>
            </div>
        </div>
    </div>
    
    <!-- PDF floating page indicator -->
    {% if is_pdf %}
    <div id="pdf-page-indicator"></div>
    
    <!-- Page jump control -->
    <div id="page-jump-container">
        <input type="number" id="page-jump-input" min="1" max="{{ book.spine|length }}" placeholder="Page">
        <button id="page-jump-btn" onclick="jumpToPage()">Go</button>
    </div>
    
    <!-- PDF reprocess banner for old-style PDFs -->
    {% if needs_reprocess %}
    <div id="pdf-reprocess-banner" style="position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(135deg, #f39c12, #e74c3c); color: #fff; padding: 12px 20px; z-index: 2000; font-family: -apple-system, sans-serif; display: flex; align-items: center; justify-content: center; gap: 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);">
        <span style="font-size: 1.1em;">⚠️ This PDF uses old text-based rendering which may display incorrectly.</span>
        <button onclick="reprocessPDF()" style="background: #fff; color: #e74c3c; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 0.9em;">Reprocess PDF</button>
        <button onclick="dismissReprocessBanner()" style="background: transparent; color: #fff; border: 1px solid rgba(255,255,255,0.5); padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 0.9em;">Dismiss</button>
    </div>
    {% endif %}
    {% endif %}

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="/" class="nav-home">← Back to Library</a>
        <div class="nav-header">{{ book.metadata.title }}</div>
        
        <!-- Quick actions toolbar -->
        <div style="display: flex; gap: 8px; padding: 10px 15px; border-bottom: 1px solid #eee; flex-wrap: wrap;">
            <button onclick="openSearch()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Search (Ctrl/⌘+F)"><i class="fa-solid fa-magnifying-glass"></i> Search</button>
            <button onclick="toggleBookmarksPanel()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Bookmarks & Highlights"><i class="fa-solid fa-book-bookmark"></i> Notes</button>
        </div>
        <div style="display: flex; gap: 8px; padding: 5px 15px 10px; border-bottom: 1px solid #eee; flex-wrap: wrap;">
            <button onclick="toggleVocabularyPanel()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Vocabulary List"><i class="fa-solid fa-language"></i> Vocab</button>
            <button onclick="toggleAnnotationsPanel()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Annotations"><i class="fa-regular fa-note-sticky"></i> Annot</button>
            <button onclick="toggleSessionPanel()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Reading History"><i class="fa-solid fa-chart-simple"></i> Stats</button>
        </div>

        <!-- Multi-chapter copy controls -->
        <div class="multi-copy-controls">
            <div class="multi-copy-header">
                <span class="multi-copy-title">Multi-Chapter Copy</span>
                <div class="multi-copy-actions">
                    <button class="multi-copy-btn" onclick="selectAllChapters()">Select All</button>
                    <button class="multi-copy-btn" onclick="clearChapterSelection()">Clear</button>
                </div>
            </div>
            
            <!-- Filtering options -->
            <div class="chapter-filter">
                <select id="chapter-filter" onchange="filterChapters(this.value)">
                    <option value="all">All Chapters</option>
                    <option value="unread">Unread Only</option>
                    <option value="read">Read Only</option>
                </select>
                <input type="text" id="chapter-search" placeholder="Search chapters..." 
                       onkeyup="filterChapters(document.getElementById('chapter-filter').value)">
            </div>
            
            <button class="copy-selected-btn" onclick="copySelectedChapters()" disabled id="copy-chapters-btn">
                Copy Selected (0)
            </button>
        </div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <div class="toc-item-wrapper">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                       class="toc-link {% if is_active %}active{% endif %}"
                       data-href="{{ item.file_href }}">
                        <input type="checkbox" class="chapter-checkbox" data-href="{{ item.file_href }}" onclick="event.stopPropagation(); updateCopyButton();">
                        <span class="toc-title">{{ item.title }}</span>
                        <span class="toc-chapter-percent" data-href="{{ item.file_href }}">0%</span>
                    </a>
                    <div class="chapter-progress" data-href="{{ item.file_href }}">
                        <div class="chapter-progress-bar">
                            <div class="chapter-progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="chapter-reading-time" title="Estimated reading time">--</span>
                    </div>
                    </div>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <div class="content-toolbar {% if is_pdf %}pdf-toolbar{% endif %}">
                {% if is_pdf %}
                <button class="toolbar-btn" type="button" onclick="togglePageJump()" title="Jump to a specific page"><i class="fa-solid fa-hashtag"></i> Go to Page</button>
                <div style="display: flex; align-items: center; gap: 5px; border-left: 1px solid #ddd; padding-left: 10px; margin-left: 5px;">
                    <input type="number" id="page-range-input" min="1" max="50" value="3" 
                           style="width: 50px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9em; text-align: center;"
                           title="Number of pages to select after current page">
                    <button class="toolbar-btn" type="button" onclick="selectPageRange()" title="Select N pages after current page">
                        <i class="fa-solid fa-layer-group"></i> Select Range
                    </button>
                </div>
                <button class="toolbar-btn pdf-multi-copy-btn" type="button" onclick="copySelectedPagesAsImage()" id="pdf-multi-copy-btn" title="Copy selected pages as a combined image"><i class="fa-regular fa-images"></i> Copy Selected (<span id="pdf-selected-count">0</span>)</button>
                <button class="toolbar-btn pdf-clear-btn" type="button" onclick="clearPdfSelection()" id="pdf-clear-btn" title="Clear selection"><i class="fa-solid fa-xmark"></i> Clear</button>
                <button class="toolbar-btn" type="button" onclick="toggleSelectAllPages()" id="pdf-select-all-btn" title="Select/Deselect all loaded pages"><i class="fa-regular fa-square-check"></i> Select All</button>
                {% else %}
                <button class="toolbar-btn" type="button" onclick="copyAllLoaded()" id="copy-all-btn" title="Copy all loaded content"><i class="fa-regular fa-copy"></i> Copy All</button>
                <button class="toolbar-btn" type="button" onclick="showBatchClipboard()" id="batch-clipboard-btn" style="display: none;"><i class="fa-regular fa-folder-open"></i> Batch (<span id="batch-count">0</span>)</button>
                {% endif %}
            </div>
            <div id="copy-status" aria-live="polite"></div>
            <div class="book-content" id="book-content">
                {% if is_pdf %}
                <div class="pdf-page" data-page-index="{{ chapter_index }}">
                    <div class="pdf-page-header">
                        <input type="checkbox" class="pdf-page-select" data-page-index="{{ chapter_index }}" onchange="updatePdfPageSelection(this)" title="Select page for multi-copy">
                        <span class="pdf-page-number">Page {{ chapter_index + 1 }}</span>
                        <div class="pdf-page-actions">
                            <button class="pdf-copy-image-btn" onclick="copyPageImage(this, {{ chapter_index }})" title="Copy page as image to clipboard">
                                <i class="fa-regular fa-image"></i> Copy Image
                            </button>
                            <button class="pdf-copy-image-btn" onclick="copyPageText(this, {{ chapter_index }})" title="Copy page text to clipboard">
                                <i class="fa-regular fa-copy"></i> Copy Text
                            </button>
                        </div>
                    </div>
                    {{ current_chapter.content | safe }}
                </div>
                {% else %}
                {{ current_chapter.content | safe }}
                {% endif %}
            </div>

            {% if not is_pdf %}
            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">← Previous</a>
                {% else %}
                    <span class="nav-btn disabled">← Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next →</a>
                {% else %}
                    <span class="nav-btn disabled">Next →</span>
                {% endif %}
            </div>
            {% else %}
            <div id="pdf-scroll-indicator" style="text-align: center; padding: 20px; font-family: -apple-system, sans-serif;">
                <div style="color: #999; font-size: 0.9em; margin-bottom: 15px;">
                    <span id="page-count">Page {{ chapter_index + 1 }} of {{ book.spine|length }}</span>
                </div>
                <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                    <button class="toolbar-btn" onclick="scrollToTop()" title="Back to top"><i class="fa-solid fa-arrow-up"></i> Top</button>
                    <button class="toolbar-btn" onclick="loadAllPages()" id="load-all-btn" title="Load all remaining pages">Load All Pages</button>
                </div>
            </div>
            {% endif %}
        </div>
    </div>

    <script>
        const isPDF = {{ 'true' if is_pdf else 'false' }};
        const bookId = {{ book_id | tojson }};
        const totalPages = {{ book.spine|length }};
        let currentPageIndex = {{ chapter_index }};
        let loadingPages = false;
        let visiblePageRange = { start: 0, end: 0 };
        
        // Batch clipboard for collecting multiple text selections
        let batchClipboard = [];
        let isSelectionMode = false;
        
        // User data: bookmarks, highlights, reading progress
        let userBookmarks = [];
        let userHighlights = [];
        let savedProgress = null;
        let searchHistory = [];
        
        // New feature data
        let userVocabulary = [];
        let userAnnotations = [];
        let readingSessions = [];
        let currentSessionId = null;
        let sessionStartTime = null;
        let currentNoteContext = null; // For add note modal
        
        // ===== PDF REPROCESS FUNCTIONS =====
        
        async function reprocessPDF() {
            const banner = document.getElementById('pdf-reprocess-banner');
            if (banner) {
                banner.innerHTML = '<span style="font-size: 1.1em;"><i class="fa-solid fa-spinner fa-spin"></i> Reprocessing PDF... This may take a moment.</span>';
            }
            
            try {
                const response = await fetch(`/api/reprocess/${encodeURIComponent(bookId)}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    // Reload the page to see the new rendering
                    window.location.reload();
                } else {
                    const data = await response.json();
                    alert('Failed to reprocess: ' + (data.detail || 'Unknown error'));
                    if (banner) {
                        banner.innerHTML = `
                            <span style="font-size: 1.1em;">❌ Reprocess failed. Please re-upload the PDF.</span>
                            <button onclick="dismissReprocessBanner()" style="background: transparent; color: #fff; border: 1px solid rgba(255,255,255,0.5); padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 0.9em;">Dismiss</button>
                        `;
                    }
                }
            } catch (err) {
                alert('Error reprocessing PDF: ' + err.message);
            }
        }
        
        function dismissReprocessBanner() {
            const banner = document.getElementById('pdf-reprocess-banner');
            if (banner) {
                banner.style.display = 'none';
            }
        }
        
        // ===== USER DATA API FUNCTIONS =====
        
        async function loadUserData() {
            try {
                // Load bookmarks
                const bookmarksRes = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`);
                if (bookmarksRes.ok) {
                    const bookmarksData = await bookmarksRes.json();
                    userBookmarks = bookmarksData.bookmarks || [];
                }
                
                // Load highlights
                const highlightsRes = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`);
                if (highlightsRes.ok) {
                    const highlightsData = await highlightsRes.json();
                    userHighlights = highlightsData.highlights || [];
                    applyHighlights();
                }
                
                // Load reading progress
                const progressRes = await fetch(`/api/progress/${encodeURIComponent(bookId)}`);
                if (progressRes.ok) {
                    savedProgress = await progressRes.json();
                    checkShowResumeBanner();
                }
                
                // Load search history
                const historyRes = await fetch('/api/search/history');
                if (historyRes.ok) {
                    const historyData = await historyRes.json();
                    searchHistory = (historyData.history || []).slice(0, 10);
                }
                
                // Load vocabulary
                const vocabRes = await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}`);
                if (vocabRes.ok) {
                    const vocabData = await vocabRes.json();
                    userVocabulary = vocabData.words || [];
                }
                
                // Load annotations
                const annotRes = await fetch(`/api/annotations/${encodeURIComponent(bookId)}`);
                if (annotRes.ok) {
                    const annotData = await annotRes.json();
                    userAnnotations = annotData.annotations || [];
                }
                
                // Load reading sessions
                const sessionsRes = await fetch('/api/sessions');
                if (sessionsRes.ok) {
                    const sessionsData = await sessionsRes.json();
                    readingSessions = sessionsData.sessions || [];
                }
                
                // Render panels
                renderBookmarksList();
                renderHighlightsList();
                renderSearchHistory();
                renderVocabularyList();
                renderAnnotationsList();
                renderSessionList();
                
                // Start new reading session
                startReadingSession();
            } catch (error) {
                console.error('Failed to load user data:', error);
            }
        }
        
        // ===== READING PROGRESS =====
        
        function updateReadingProgress() {
            const mainEl = document.getElementById('main');
            if (!mainEl) return 0;
            
            const scrollTop = mainEl.scrollTop;
            const scrollHeight = mainEl.scrollHeight - mainEl.clientHeight;
            const progress = scrollHeight > 0 ? (scrollTop / scrollHeight) * 100 : 0;
            
            const progressBar = document.getElementById('reading-progress-bar');
            if (progressBar) {
                progressBar.style.width = progress + '%';
            }
            
            // Also update the current chapter's progress bar in the sidebar
            updateCurrentChapterProgress(progress);
            
            return progress;
        }
        
        function updateCurrentChapterProgress(progress) {
            // Find the current chapter's progress bar in the sidebar
            const currentHref = "{{ current_chapter.href }}";
            const progressElem = document.querySelector(`.chapter-progress[data-href="${currentHref}"] .chapter-progress-fill`);
            if (progressElem) {
                progressElem.style.width = `${Math.min(100, progress)}%`;
            }
            
            // Mark as read if 90%+
            if (progress >= 90) {
                const link = document.querySelector(`.toc-link[data-href="${currentHref}"]`);
                if (link && !link.classList.contains('read')) {
                    link.classList.add('read');
                }
            }
        }
        
        let progressSaveTimeout = null;
        async function saveReadingProgress() {
            if (progressSaveTimeout) clearTimeout(progressSaveTimeout);
            
            progressSaveTimeout = setTimeout(async () => {
                const progress = updateReadingProgress();
                const mainEl = document.getElementById('main');
                const scrollPosition = mainEl ? mainEl.scrollTop : 0;
                
                try {
                    // Save overall reading progress
                    await fetch(`/api/progress/${encodeURIComponent(bookId)}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chapter_index: currentPageIndex,
                            scroll_position: scrollPosition,
                            progress_percent: progress
                        })
                    });
                    
                    // Also save chapter-specific progress
                    await fetch(`/api/chapter-progress/${encodeURIComponent(bookId)}/${currentPageIndex}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ progress: progress })
                    });
                } catch (error) {
                    console.error('Failed to save progress:', error);
                }
            }, 1000);
        }
        
        function checkShowResumeBanner() {
            if (savedProgress && savedProgress.scroll_position > 100) {
                const banner = document.getElementById('resume-banner');
                if (banner) {
                    banner.classList.add('visible');
                }
            }
        }
        
        function resumeReading() {
            if (savedProgress) {
                const mainEl = document.getElementById('main');
                if (mainEl) {
                    mainEl.scrollTo({ top: savedProgress.scroll_position, behavior: 'smooth' });
                }
            }
            dismissResume();
        }
        
        function dismissResume() {
            const banner = document.getElementById('resume-banner');
            if (banner) {
                banner.classList.remove('visible');
            }
        }
        
        // ===== BOOKMARKS =====
        
        async function addBookmark() {
            const selection = window.getSelection();
            const text = selection.toString().trim();
            
            if (!text) {
                showToast('Select text to bookmark', 'error');
                return;
            }
            
            const note = prompt('Add a note (optional):');
            
            try {
                const mainEl = document.getElementById('main');
                const scrollPos = mainEl ? mainEl.scrollTop / mainEl.scrollHeight : 0;
                const response = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: currentPageIndex,
                        scroll_position: scrollPos,
                        title: text.substring(0, 100),
                        note: note || ''
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Reload bookmarks to get full data
                    await loadBookmarksFromServer();
                    renderBookmarksList();
                    showToast('Bookmark added!');
                    hideSelectionToolbar();
                } else {
                    showToast('Failed to add bookmark', 'error');
                }
            } catch (error) {
                console.error('Failed to add bookmark:', error);
                showToast('Failed to add bookmark', 'error');
            }
        }
        
        async function loadBookmarksFromServer() {
            try {
                const response = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    userBookmarks = data.bookmarks || [];
                }
            } catch (error) {
                console.error('Failed to load bookmarks:', error);
            }
        }
        
        async function deleteBookmark(id) {
            try {
                await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}/${id}`, {
                    method: 'DELETE'
                });
                userBookmarks = userBookmarks.filter(b => b.id !== id);
                renderBookmarksList();
                showToast('Bookmark removed');
            } catch (error) {
                console.error('Failed to delete bookmark:', error);
            }
        }
        
        function goToBookmark(bookmark) {
            // scroll_position is 0-1, convert to pixels
            const mainEl = document.getElementById('main');
            if (mainEl) {
                const scrollPos = bookmark.scroll_position * mainEl.scrollHeight;
                mainEl.scrollTo({ top: scrollPos, behavior: 'smooth' });
            }
            toggleBookmarksPanel();
        }
        
        function renderBookmarksList() {
            const list = document.getElementById('bookmarks-list');
            if (!list) return;
            
            if (userBookmarks.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i class="fa-regular fa-bookmark" style="font-size: 2em; color: #ccc;"></i></div>
                        <div class="empty-state-text">No bookmarks yet</div>
                        <div class="empty-state-hint">Select text and click the bookmark button to save passages</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = userBookmarks.map(b => `
                <div class="bookmark-item">
                    <div class="bookmark-actions">
                        <button class="bookmark-action-btn" onclick="deleteBookmark('${b.id}')" title="Delete"><i class="fa-regular fa-trash-can"></i></button>
                    </div>
                    <div class="bookmark-title" onclick="goToBookmark(${JSON.stringify(b).replace(/"/g, '&quot;')})">"${escapeHtml(b.title || 'Bookmark')}"</div>
                    <div class="bookmark-meta">Chapter ${b.chapter_index + 1} • ${new Date(b.created_at).toLocaleDateString()}</div>
                    ${b.note ? `<div class="bookmark-note">${escapeHtml(b.note)}</div>` : ''}
                </div>
            `).join('');
        }
        
        // ===== HIGHLIGHTS =====
        
        async function highlightSelection(color) {
            const selection = window.getSelection();
            const text = selection.toString().trim();
            
            if (!text) {
                showToast('Select text to highlight', 'error');
                return;
            }
            
            // Get selection range info for restoration
            const range = selection.getRangeAt(0);
            const startContainer = getXPath(range.startContainer);
            const endContainer = getXPath(range.endContainer);
            
            try {
                const response = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: currentPageIndex,
                        text: text.substring(0, 1000),
                        color: color,
                        start_offset: range.startOffset,
                        end_offset: range.endOffset,
                        note: ''
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Reload highlights to get full data
                    await loadHighlightsFromServer();
                    
                    // Apply visual highlight
                    applyHighlightToRange(range, color, result.id);
                    
                    renderHighlightsList();
                    showToast(`Highlighted in ${color}! ✨`);
                    hideSelectionToolbar();
                    selection.removeAllRanges();
                } else {
                    showToast('Failed to add highlight', 'error');
                }
            } catch (error) {
                console.error('Failed to add highlight:', error);
                showToast('Failed to add highlight', 'error');
            }
        }
        
        async function loadHighlightsFromServer() {
            try {
                const response = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    userHighlights = data.highlights || [];
                }
            } catch (error) {
                console.error('Failed to load highlights:', error);
            }
        }
        
        function applyHighlightToRange(range, color, id) {
            const span = document.createElement('span');
            span.className = `highlight-mark highlight-${color}`;
            span.dataset.highlightId = id;
            span.onclick = (e) => showHighlightMenu(id, e);
            
            try {
                range.surroundContents(span);
            } catch (e) {
                // Complex selection - fall back to simple text marking
                const text = range.toString();
                const mark = document.createElement('mark');
                mark.className = `highlight-mark highlight-${color}`;
                mark.dataset.highlightId = id;
                mark.textContent = text;
                range.deleteContents();
                range.insertNode(mark);
            }
        }
        
        function applyHighlights() {
            // Re-apply highlights on page load
            userHighlights.forEach(h => {
                if (h.chapter_index !== currentPageIndex) return;
                
                // Find and highlight the text
                const content = document.getElementById('content');
                if (!content) return;
                
                const textToFind = h.text.substring(0, 50);
                const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT);
                
                while (walker.nextNode()) {
                    const node = walker.currentNode;
                    const idx = node.textContent.indexOf(textToFind);
                    if (idx !== -1) {
                        const range = document.createRange();
                        range.setStart(node, idx);
                        range.setEnd(node, Math.min(idx + h.text.length, node.textContent.length));
                        applyHighlightToRange(range, h.color, h.id);
                        break;
                    }
                }
            });
        }
        
        let currentHighlightId = null;
        
        function showHighlightMenu(id, event) {
            event = event || window.event;
            event.preventDefault();
            event.stopPropagation();
            
            currentHighlightId = id;
            const menu = document.getElementById('highlight-context-menu');
            
            // Get current highlight color
            const highlight = userHighlights.find(h => h.id === id);
            const currentColor = highlight ? highlight.color : 'yellow';
            
            // Update active color indicator
            menu.querySelectorAll('.highlight-menu-color').forEach(el => {
                el.classList.remove('active');
                if (el.classList.contains(currentColor)) {
                    el.classList.add('active');
                }
            });
            
            // Position the menu near the click
            const x = event.clientX || event.pageX;
            const y = event.clientY || event.pageY;
            
            menu.style.left = `${Math.min(x, window.innerWidth - 180)}px`;
            menu.style.top = `${Math.min(y, window.innerHeight - 150)}px`;
            menu.classList.add('visible');
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeHighlightMenu);
            }, 10);
        }
        
        function closeHighlightMenu() {
            const menu = document.getElementById('highlight-context-menu');
            menu.classList.remove('visible');
            document.removeEventListener('click', closeHighlightMenu);
            currentHighlightId = null;
        }
        
        function deleteCurrentHighlight() {
            if (currentHighlightId) {
                deleteHighlight(currentHighlightId);
                closeHighlightMenu();
            }
        }
        
        function copyHighlightText() {
            if (!currentHighlightId) return;
            
            const highlight = userHighlights.find(h => h.id === currentHighlightId);
            if (highlight && highlight.text) {
                clipboardWriteText(highlight.text).then(() => {
                    showToast('Text copied to clipboard');
                }).catch(() => {
                    showToast('Failed to copy text', 'error');
                });
            }
            closeHighlightMenu();
        }
        
        async function changeHighlightColor(newColor) {
            if (!currentHighlightId) return;
            
            const highlight = userHighlights.find(h => h.id === currentHighlightId);
            if (!highlight || highlight.color === newColor) {
                closeHighlightMenu();
                return;
            }
            
            try {
                // Update on server
                await fetch(`/api/highlights/${encodeURIComponent(bookId)}/${currentHighlightId}/color`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ color: newColor })
                });
                
                // Update visual highlight
                const el = document.querySelector(`[data-highlight-id="${currentHighlightId}"]`);
                if (el) {
                    el.className = `highlight-mark highlight-${newColor}`;
                }
                
                // Update local data
                highlight.color = newColor;
                renderHighlightsList();
                showToast(`Changed to ${newColor}`);
            } catch (error) {
                console.error('Failed to change highlight color:', error);
                showToast('Failed to change color', 'error');
            }
            closeHighlightMenu();
        }
        
        async function deleteHighlight(id) {
            try {
                await fetch(`/api/highlights/${encodeURIComponent(bookId)}/${id}`, {
                    method: 'DELETE'
                });
                
                // Remove visual highlight
                const el = document.querySelector(`[data-highlight-id="${id}"]`);
                if (el) {
                    const parent = el.parentNode;
                    parent.replaceChild(document.createTextNode(el.textContent), el);
                    parent.normalize();
                }
                
                userHighlights = userHighlights.filter(h => h.id !== id);
                renderHighlightsList();
                showToast('Highlight removed');
            } catch (error) {
                console.error('Failed to delete highlight:', error);
            }
        }
        
        function renderHighlightsList() {
            const list = document.getElementById('highlights-list');
            if (!list) return;
            
            if (userHighlights.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i class="fa-solid fa-highlighter" style="font-size: 2em; color: #ccc;"></i></div>
                        <div class="empty-state-text">No highlights yet</div>
                        <div class="empty-state-hint">Select text and choose a color to highlight important passages</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = userHighlights.map(h => `
                <div class="highlight-item">
                    <div class="bookmark-actions">
                        <button class="bookmark-action-btn" onclick="deleteHighlight('${h.id}')" title="Delete"><i class="fa-regular fa-trash-can"></i></button>
                    </div>
                    <div class="highlight-text highlight-${h.color}">"${escapeHtml((h.text || '').substring(0, 150))}${(h.text || '').length > 150 ? '...' : ''}"</div>
                    <div class="bookmark-meta">Chapter ${h.chapter_index + 1} • ${new Date(h.created_at).toLocaleDateString()}</div>
                </div>
            `).join('');
        }
        
        // ===== BOOKMARKS PANEL =====
        
        function toggleBookmarksPanel() {
            const panel = document.getElementById('bookmarks-panel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }
        
        function showPanelTab(tab) {
            const tabs = document.querySelectorAll('.panel-tab');
            tabs.forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            const bookmarksList = document.getElementById('bookmarks-list');
            const highlightsList = document.getElementById('highlights-list');
            
            if (tab === 'bookmarks') {
                bookmarksList.style.display = 'block';
                highlightsList.style.display = 'none';
            } else {
                bookmarksList.style.display = 'none';
                highlightsList.style.display = 'block';
            }
        }
        
        async function exportNotes(format) {
            try {
                const response = await fetch(`/api/export/${encodeURIComponent(bookId)}?format=${format}`);
                if (response.ok) {
                    const content = await response.text();
                    const filename = `${bookId}_notes.${format === 'markdown' ? 'md' : 'json'}`;
                    
                    const mimeType = format === 'markdown' ? 'text/markdown' : 'application/json';
                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    showToast('Notes exported! 📁');
                } else {
                    showToast('Export failed', 'error');
                }
            } catch (error) {
                console.error('Export failed:', error);
                showToast('Export failed', 'error');
            }
        }
        
        // ===== SEARCH =====
        
        function openSearch() {
            const modal = document.getElementById('search-modal');
            if (modal) {
                modal.classList.add('visible');
                document.getElementById('search-input').focus();
            }
        }
        
        function closeSearch() {
            const modal = document.getElementById('search-modal');
            if (modal) {
                modal.classList.remove('visible');
            }
        }
        
        async function performSearch() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) return;
            
            const resultsContainer = document.getElementById('search-results');
            resultsContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">Searching...</p>';
            
            try {
                const response = await fetch(`/api/search?q=${encodeURIComponent(query)}&book_id=${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    
                    // Add to history
                    if (!searchHistory.includes(query)) {
                        searchHistory.unshift(query);
                        searchHistory = searchHistory.slice(0, 10);
                    }
                    
                    renderSearchResults(data.results, query);
                }
            } catch (error) {
                console.error('Search failed:', error);
                resultsContainer.innerHTML = '<p style="text-align: center; color: #e74c3c; padding: 20px;">Search failed</p>';
            }
        }
        
        function renderSearchResults(results, query) {
            const container = document.getElementById('search-results');
            
            if (results.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i class="fa-solid fa-magnifying-glass" style="font-size: 2em; color: #ccc;"></i></div>
                        <div class="empty-state-text">No results found</div>
                        <div class="empty-state-hint">Try different keywords or check spelling</div>
                    </div>
                `;
                return;
            }
            
            // Group results by chapter
            const grouped = {};
            results.forEach(r => {
                if (!grouped[r.chapter_index]) {
                    grouped[r.chapter_index] = {
                        chapter: r,
                        matches: []
                    };
                }
                grouped[r.chapter_index].matches.push(r);
            });
            
            const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
            
            container.innerHTML = `
                <div style="padding: 10px 20px; background: #f5f5f5; font-size: 0.9em; color: #666; margin-bottom: 10px;">
                    ${results.length} result${results.length > 1 ? 's' : ''} found
                </div>
            ` + Object.values(grouped).map(g => `
                <div style="margin-bottom: 10px;">
                    <div style="font-weight: 600; color: #333; padding: 10px 15px; background: #f9f9f9; border-left: 3px solid #3498db;">
                        ${g.chapter.chapter_title || 'Chapter ' + (g.chapter.chapter_index + 1)} (${g.matches.length} match${g.matches.length > 1 ? 'es' : ''})
                    </div>
                    ${g.matches.map((r, idx) => `
                        <div class="search-result" onclick="goToSearchResult(${r.chapter_index}, '${encodeURIComponent(query)}', ${idx})">
                            <div class="search-result-context">${r.context.replace(regex, '<mark>$1</mark>')}</div>
                        </div>
                    `).join('')}
                </div>
            `).join('');
        }
        
        // Store current highlights for cleanup
        let currentHighlights = [];
        
        function goToSearchResult(chapterIndex, query, matchIndex) {
            closeSearch();
            const decodedQuery = decodeURIComponent(query);
            const content = document.getElementById('book-content');
            const mainEl = document.getElementById('main');
            
            if (!content || !mainEl) return;
            
            // Clear previous highlights
            clearHighlights();
            
            // Find all instances of the search term in the content
            const matches = findAllTextMatches(content, decodedQuery);
            
            if (matches.length === 0) return;
            
            // Highlight all instances with different colors
            matches.forEach((match, index) => {
                const span = document.createElement('span');
                
                // First match gets bright highlight, others get subtle highlight
                if (index === matchIndex || matches.length === 1) {
                    span.style.background = '#ffeb3b';
                    span.style.color = '#000';
                    span.style.fontWeight = 'bold';
                    
                    // Scroll the first occurrence into view
                    if (index === matchIndex || matchIndex === 0) {
                        setTimeout(() => {
                            const rect = span.getBoundingClientRect();
                            const mainRect = mainEl.getBoundingClientRect();
                            mainEl.scrollTo({
                                top: mainEl.scrollTop + rect.top - mainRect.top - 100,
                                behavior: 'smooth'
                            });
                        }, 50);
                    }
                } else {
                    span.style.background = '#fff59d';
                    span.style.color = '#000';
                }
                
                span.style.transition = 'background 0.3s ease, color 0.3s ease';
                span.style.padding = '2px 4px';
                span.style.borderRadius = '3px';
                span.className = 'search-highlight';
                
                // Wrap the matched text
                const range = match.range;
                try {
                    range.surroundContents(span);
                    currentHighlights.push(span);
                } catch (e) {
                    // If surroundContents fails (complex DOM), use alternative
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span);
                    currentHighlights.push(span);
                }
            });
            
            // Remove highlights after 3 seconds
            setTimeout(clearHighlights, 3000);
        }
        
        function findAllTextMatches(element, searchTerm) {
            const matches = [];
            const regex = new RegExp(escapeRegex(searchTerm), 'gi');
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                let match;
                while ((match = regex.exec(node.textContent)) !== null) {
                    const range = document.createRange();
                    range.setStart(node, match.index);
                    range.setEnd(node, match.index + searchTerm.length);
                    matches.push({ range, text: match[0] });
                }
                regex.lastIndex = 0;
            }
            
            return matches;
        }
        
        function clearHighlights() {
            currentHighlights.forEach(span => {
                const parent = span.parentNode;
                if (parent) {
                    while (span.firstChild) {
                        parent.insertBefore(span.firstChild, span);
                    }
                    parent.removeChild(span);
                }
            });
            currentHighlights = [];
        }
        
        // Highlight search term when loaded from library search
        function performSearchHighlight(searchTerm) {
            const content = document.getElementById('book-content');
            const mainEl = document.getElementById('main');
            
            if (!content || !mainEl || !searchTerm) return;
            
            clearHighlights();
            
            // Find all instances of the search term
            const matches = findAllTextMatches(content, searchTerm);
            
            if (matches.length === 0) return;
            
            // Highlight all instances
            matches.forEach((match, index) => {
                const span = document.createElement('span');
                
                if (index === 0) {
                    // First match gets bright highlight and we scroll to it
                    span.style.background = '#ffeb3b';
                    span.style.color = '#000';
                    span.style.fontWeight = 'bold';
                    
                    // Scroll first match into view
                    setTimeout(() => {
                        const rect = span.getBoundingClientRect();
                        const mainRect = mainEl.getBoundingClientRect();
                        mainEl.scrollTo({
                            top: mainEl.scrollTop + rect.top - mainRect.top - 100,
                            behavior: 'smooth'
                        });
                    }, 50);
                } else {
                    // Other matches get subtle highlight
                    span.style.background = '#fff59d';
                    span.style.color = '#000';
                }
                
                span.style.transition = 'background 0.3s ease, color 0.3s ease';
                span.style.padding = '2px 4px';
                span.style.borderRadius = '3px';
                span.className = 'search-highlight';
                
                // Wrap the matched text
                const range = match.range;
                try {
                    range.surroundContents(span);
                    currentHighlights.push(span);
                } catch (e) {
                    // If surroundContents fails, use alternative
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span);
                    currentHighlights.push(span);
                }
            });
            
            // Remove highlights after 4 seconds
            setTimeout(clearHighlights, 4000);
        }
        
        function searchFromHistory(query) {
            document.getElementById('search-input').value = query;
            performSearch();
        }
        
        function renderSearchHistory() {
            const container = document.getElementById('search-history');
            if (!container || searchHistory.length === 0) return;
            
            container.innerHTML = `
                <div class="search-history-title">Recent searches</div>
                ${searchHistory.map(h => `<span class="search-history-item" onclick="searchFromHistory('${escapeHtml(h.query || h)}')">${escapeHtml(h.query || h)}</span>`).join('')}
            `;
        }
        
        // ===== UTILITY FUNCTIONS =====
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function getXPath(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                return getXPath(node.parentNode) + '/text()';
            }
            if (node === document.body) return '/html/body';
            
            let position = 1;
            let sibling = node.previousSibling;
            while (sibling) {
                if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === node.tagName) {
                    position++;
                }
                sibling = sibling.previousSibling;
            }
            return getXPath(node.parentNode) + '/' + node.tagName.toLowerCase() + '[' + position + ']';
        }
        
        // Toast notification system
        function showToast(message, type = 'success') {
            const toast = document.getElementById('copy-toast');
            if (!toast) return;
            
            toast.textContent = message;
            toast.className = 'visible ' + type;
            
            setTimeout(() => {
                toast.className = '';
            }, 2500);
        }
        
        // PDF: Toggle page jump control
        function togglePageJump() {
            const container = document.getElementById('page-jump-container');
            if (container) {
                container.classList.toggle('visible');
                if (container.classList.contains('visible')) {
                    document.getElementById('page-jump-input').focus();
                }
            }
        }
        
        // PDF: Jump to specific page
        function jumpToPage() {
            const input = document.getElementById('page-jump-input');
            const pageNum = parseInt(input.value);
            
            if (pageNum && pageNum >= 1 && pageNum <= totalPages) {
                window.location.href = `/read/${bookId}/${pageNum - 1}`;
            } else {
                showToast(`Enter a page between 1 and ${totalPages}`, 'error');
            }
        }
        
        // PDF: Load all remaining pages
        async function loadAllPages() {
            if (!isPDF || loadingPages) return;
            
            const btn = document.getElementById('load-all-btn');
            if (btn) {
                btn.textContent = 'Loading...';
                btn.disabled = true;
            }
            
            loadingPages = true;
            
            while (currentPageIndex < totalPages - 1) {
                const nextStart = currentPageIndex + 1;
                try {
                    const resp = await fetch(`/read/${bookId}/pages/${nextStart}/10`);
                    const data = await resp.json();
                    
                    if (data.pages && data.pages.length > 0) {
                        const contentDiv = document.getElementById('book-content');
                        data.pages.forEach(page => {
                            const pageWrapper = document.createElement('div');
                            pageWrapper.className = 'pdf-page';
                            pageWrapper.dataset.pageIndex = page.index;
                            pageWrapper.innerHTML = `
                                <div class="pdf-page-header">
                                    <span class="pdf-page-number">${page.title}</span>
                                </div>
                                ${page.content}
                            `;
                            contentDiv.appendChild(pageWrapper);
                        });
                        
                        currentPageIndex = Math.max(...data.pages.map(p => p.index));
                        updatePageIndicator();
                        updateProgressBar();
                    } else {
                        break;
                    }
                } catch (err) {
                    console.error('Failed to load pages:', err);
                    break;
                }
            }
            
            loadingPages = false;
            
            if (btn) {
                btn.innerHTML = '<i class="fa-solid fa-check"></i> All Pages Loaded';
                btn.disabled = true;
            }
            
            showToast(`Loaded all ${totalPages} pages!`, 'success');
        }
        
        // Scroll to top
        function scrollToTop() {
            document.getElementById('main').scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // Update progress bar
        function updateProgressBar() {
            const progress = document.getElementById('pdf-progress');
            if (progress) {
                const percent = ((currentPageIndex + 1) / totalPages) * 100;
                progress.style.width = percent + '%';
            }
        }
        
        // Show floating page indicator on scroll
        let pageIndicatorTimeout;
        function showPageIndicator(pageNum) {
            const indicator = document.getElementById('pdf-page-indicator');
            if (!indicator) return;
            
            indicator.textContent = `Page ${pageNum} of ${totalPages}`;
            indicator.classList.add('visible');
            
            clearTimeout(pageIndicatorTimeout);
            pageIndicatorTimeout = setTimeout(() => {
                indicator.classList.remove('visible');
            }, 1500);
        }
        
        // Selection mode toggle (kept for non-PDF)
        function toggleSelectionMode() {
            isSelectionMode = !isSelectionMode;
            document.body.classList.toggle('selection-mode', isSelectionMode);
            const btn = document.getElementById('selection-mode-btn');
            if (btn) {
                btn.classList.toggle('active', isSelectionMode);
                btn.innerHTML = isSelectionMode ? '<i class="fa-solid fa-check"></i> Selection Mode' : '<i class="fa-regular fa-edit"></i> Select Text';
            }
            if (!isSelectionMode) {
                hideSelectionToolbar();
            }
        }
        
        // Copy text from a specific PDF page
        async function copyPageText(button, pageIndex) {
            // First try the hidden text element already in the DOM
            let textToCopy = '';
            const textElement = document.getElementById(`pdf-text-${pageIndex}`);
            if (textElement) {
                textToCopy = textElement.textContent.trim();
            }

            // If no text found in DOM, fetch from text-layer API
            if (!textToCopy) {
                try {
                    const resp = await fetch(`/api/pdf/${encodeURIComponent(bookId)}/text-layer/${pageIndex}`);
                    if (resp.ok) {
                        const data = await resp.json();
                        if (data.blocks && data.blocks.length > 0) {
                            textToCopy = data.blocks.map(b => b.text).join('\n').trim();
                        }
                    }
                } catch (e) {
                    console.error('Text layer fetch failed:', e);
                }
            }

            if (!textToCopy) {
                showCopyToast('No text found on this page', 'info');
                return;
            }

            try {
                await clipboardWriteText(textToCopy);
                button.classList.add('copied');
                const originalText = button.innerHTML;
                button.innerHTML = '<i class="fa-solid fa-check"></i> Copied!';
                showCopyToast('Page text copied!', 'success');
                setTimeout(() => {
                    button.classList.remove('copied');
                    button.innerHTML = originalText;
                }, 2000);
            } catch (err) {
                showCopyToast('Failed to copy text', 'error');
            }
        }

        // Copy a PDF page image to clipboard
        async function copyPageImage(button, pageIndex) {
            if (!navigator.clipboard || !window.ClipboardItem) {
                showCopyToast('Image clipboard not supported', 'error');
                return;
            }

            const pageEl = button.closest('.pdf-page') || document.querySelector(`.pdf-page[data-page-index="${pageIndex}"]`);
            if (!pageEl) {
                showCopyToast('Page not found', 'error');
                return;
            }

            const imgEl = pageEl.querySelector('img.pdf-page-image');
            if (!imgEl || !imgEl.src) {
                showCopyToast('Page image not available', 'error');
                return;
            }

            try {
                const response = await fetch(imgEl.src, { cache: 'force-cache' });
                if (!response.ok) throw new Error('Image fetch failed');
                const blob = await response.blob();
                const item = new ClipboardItem({ [blob.type || 'image/png']: blob });
                await navigator.clipboard.write([item]);

                button.classList.add('copied');
                const originalText = button.innerHTML;
                button.innerHTML = '<i class="fa-solid fa-check"></i> Copied!';
                showCopyToast('Page image copied!', 'success');
                setTimeout(() => {
                    button.classList.remove('copied');
                    button.innerHTML = originalText;
                }, 2000);
            } catch (err) {
                showCopyToast('Failed to copy image', 'error');
            }
        }
        
        // Track selected PDF pages for multi-copy
        let selectedPdfPages = new Set();
        
        // Update PDF page selection state
        function updatePdfPageSelection(checkbox) {
            const pageIndex = parseInt(checkbox.dataset.pageIndex);
            const pageEl = checkbox.closest('.pdf-page');
            
            if (checkbox.checked) {
                selectedPdfPages.add(pageIndex);
                pageEl?.classList.add('selected');
            } else {
                selectedPdfPages.delete(pageIndex);
                pageEl?.classList.remove('selected');
            }
            
            updatePdfMultiCopyButton();
        }
        
        // Update the multi-copy button visibility and count
        function updatePdfMultiCopyButton() {
            const btn = document.getElementById('pdf-multi-copy-btn');
            const clearBtn = document.getElementById('pdf-clear-btn');
            const countSpan = document.getElementById('pdf-selected-count');
            
            if (btn && countSpan) {
                countSpan.textContent = selectedPdfPages.size;
                if (selectedPdfPages.size > 0) {
                    btn.classList.add('visible');
                    clearBtn?.classList.add('visible');
                } else {
                    btn.classList.remove('visible');
                    clearBtn?.classList.remove('visible');
                }
            }
        }
        
        // Toggle select all loaded pages
        function toggleSelectAllPages() {
            const checkboxes = document.querySelectorAll('.pdf-page-select');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = !allChecked;
                updatePdfPageSelection(checkbox);
            });
            
            // Update button text
            const btn = document.getElementById('pdf-select-all-btn');
            if (btn) {
                btn.innerHTML = allChecked ? '<i class="fa-regular fa-square-check"></i> Select All' : '<i class="fa-regular fa-square"></i> Deselect All';
            }
        }

        // Select a range of pages starting from current page or user-checked page
        async function selectPageRange() {
            const input = document.getElementById('page-range-input');
            const numPages = parseInt(input.value);
            
            if (!numPages || numPages < 1) {
                showCopyToast('Enter a valid number of pages', 'error');
                return;
            }

            // If the user already checked one or more pages, start from the
            // lowest selected page instead of the viewport heuristic.
            let startPageIndex = null;
            if (selectedPdfPages.size > 0) {
                startPageIndex = Math.min(...selectedPdfPages);
            }

            // Clear existing selection *after* we've captured the anchor
            clearPdfSelection();

            // Fall back to viewport heuristic only when no page was pre-selected
            if (startPageIndex === null) {
                const mainContent = document.getElementById('main');
                const viewportMid = mainContent.getBoundingClientRect().top + mainContent.clientHeight / 2;
                const pages = document.querySelectorAll('.pdf-page');
                let bestDist = Infinity;
                startPageIndex = currentPageIndex;

                pages.forEach(page => {
                    const pageIndex = parseInt(page.dataset.pageIndex);
                    const rect = page.getBoundingClientRect();
                    const pageCenter = rect.top + rect.height / 2;
                    const dist = Math.abs(pageCenter - viewportMid);

                    if (dist < bestDist) {
                        bestDist = dist;
                        startPageIndex = pageIndex;
                    }
                });
            }

            // Calculate range
            const endPageIndex = Math.min(startPageIndex + numPages - 1, totalPages - 1);
            
            // First, ensure all pages in range are loaded
            if (endPageIndex > currentPageIndex) {
                showCopyToast(`Loading pages ${startPageIndex + 1}-${endPageIndex + 1}...`, 'success');
                
                // Load pages if needed
                while (currentPageIndex < endPageIndex) {
                    if (loadingPages) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        continue;
                    }
                    
                    loadingPages = true;
                    const nextStart = currentPageIndex + 1;
                    
                    try {
                        const resp = await fetch(`/read/${bookId}/pages/${nextStart}/10`);
                        const data = await resp.json();
                        
                        if (data.pages && data.pages.length > 0) {
                            const contentDiv = document.getElementById('book-content');
                            data.pages.forEach(page => {
                                const pageWrapper = document.createElement('div');
                                pageWrapper.className = 'pdf-page';
                                pageWrapper.dataset.pageIndex = page.index;
                                
                                pageWrapper.innerHTML = `
                                    <div class="pdf-page-header">
                                        <input type="checkbox" class="pdf-page-select" data-page-index="${page.index}" onchange="updatePdfPageSelection(this)" title="Select page for multi-copy">
                                        <span class="pdf-page-number">${page.title}</span>
                                        <div class="pdf-page-actions">
                                            <button class="pdf-copy-image-btn" onclick="copyPageImage(this, ${page.index})" title="Copy page as image to clipboard">
                                                <i class="fa-regular fa-image"></i> Copy Page
                                            </button>
                                        </div>
                                    </div>
                                    ${page.content}
                                `;
                                contentDiv.appendChild(pageWrapper);
                            });
                            
                            currentPageIndex = Math.max(...data.pages.map(p => p.index));
                            updatePageIndicator();
                            updateProgressBar();
                        } else {
                            break;
                        }
                    } catch (err) {
                        console.error('Failed to load pages:', err);
                        break;
                    } finally {
                        loadingPages = false;
                    }
                }
            }

            // Now select all pages in the range
            for (let i = startPageIndex; i <= endPageIndex; i++) {
                const checkbox = document.querySelector(`.pdf-page-select[data-page-index="${i}"]`);
                if (checkbox) {
                    checkbox.checked = true;
                    updatePdfPageSelection(checkbox);
                }
            }

            showCopyToast(`Selected pages ${startPageIndex + 1}-${endPageIndex + 1} (${endPageIndex - startPageIndex + 1} pages)`, 'success');
        }
        
        // Clear all PDF page selections
        function clearPdfSelection() {
            const checkboxes = document.querySelectorAll('.pdf-page-select');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                const pageEl = checkbox.closest('.pdf-page');
                pageEl?.classList.remove('selected');
            });
            selectedPdfPages.clear();
            updatePdfMultiCopyButton();
            
            // Reset select all button text
            const selectAllBtn = document.getElementById('pdf-select-all-btn');
            if (selectAllBtn) {
                selectAllBtn.innerHTML = '<i class="fa-regular fa-square-check"></i> Select All';
            }
        }
        
        // Copy selected pages as a combined vertical image
        async function copySelectedPagesAsImage() {
            if (selectedPdfPages.size === 0) {
                showCopyToast('No pages selected', 'error');
                return;
            }
            
            if (!navigator.clipboard || !window.ClipboardItem) {
                showCopyToast('Image clipboard not supported', 'error');
                return;
            }
            
            const btn = document.getElementById('pdf-multi-copy-btn');
            const originalText = btn?.innerHTML || '';
            if (btn) btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Processing...';
            
            try {
                // Sort selected pages by index
                const sortedPages = Array.from(selectedPdfPages).sort((a, b) => a - b);
                
                // Collect all image elements
                const images = [];
                for (const pageIndex of sortedPages) {
                    const pageEl = document.querySelector(`.pdf-page[data-page-index="${pageIndex}"]`);
                    const imgEl = pageEl?.querySelector('img.pdf-page-image');
                    
                    if (imgEl && imgEl.src) {
                        // Fetch image and create an Image object
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = imgEl.src;
                        });
                        images.push(img);
                    }
                }
                
                if (images.length === 0) {
                    showCopyToast('No images found in selected pages', 'error');
                    if (btn) btn.innerHTML = originalText;
                    return;
                }
                
                // Calculate combined canvas dimensions
                const padding = 20; // Padding between pages
                const maxWidth = Math.max(...images.map(img => img.naturalWidth));
                const totalHeight = images.reduce((sum, img) => sum + img.naturalHeight, 0) + (padding * (images.length - 1));
                
                // Create combined canvas
                const canvas = document.createElement('canvas');
                canvas.width = maxWidth;
                canvas.height = totalHeight;
                const ctx = canvas.getContext('2d');
                
                // Fill with white background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw each image centered horizontally
                let yOffset = 0;
                for (const img of images) {
                    const xOffset = (maxWidth - img.naturalWidth) / 2;
                    ctx.drawImage(img, xOffset, yOffset);
                    yOffset += img.naturalHeight + padding;
                }
                
                // Convert canvas to blob and copy to clipboard
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                const item = new ClipboardItem({ 'image/png': blob });
                await navigator.clipboard.write([item]);
                
                if (btn) {
                    btn.classList.add('copied');
                    btn.innerHTML = '<i class="fa-solid fa-check"></i> Copied!';
                }
                showCopyToast(`${images.length} page${images.length > 1 ? 's' : ''} copied as image!`, 'success');
                
                setTimeout(() => {
                    if (btn) {
                        btn.classList.remove('copied');
                        btn.innerHTML = originalText;
                    }
                }, 2000);
                
            } catch (err) {
                console.error('Failed to copy multi-page image:', err);
                showCopyToast('Failed to copy images', 'error');
                if (btn) btn.innerHTML = originalText;
            }
        }
        
        // Clipboard helper with textarea fallback for older browsers / insecure contexts
        async function clipboardWriteText(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                return navigator.clipboard.writeText(text);
            }
            // Fallback: hidden textarea + execCommand
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.style.cssText = 'position:fixed;left:-9999px;top:-9999px;opacity:0';
            document.body.appendChild(ta);
            ta.select();
            try {
                document.execCommand('copy');
            } finally {
                document.body.removeChild(ta);
            }
        }

        // Show toast notification for copy actions
        function showCopyToast(message, type) {
            let toast = document.getElementById('copy-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'copy-toast';
                document.body.appendChild(toast);
            }
            
            toast.textContent = message;
            toast.className = `visible ${type || 'success'}`;
            
            setTimeout(() => {
                toast.classList.remove('visible');
            }, 2000);
        }
        
        // Copy all loaded content (EPUB only - PDFs use image copy)
        async function copyAllLoaded() {
            if (isPDF) {
                showCopyToast('Use "Copy Text" or "Copy Image" buttons on each page', 'info');
                return;
            }
            
            const contentEl = document.getElementById('book-content');
            if (!contentEl) return;
            
            const textToCopy = contentEl.innerText.trim();
            if (!textToCopy) {
                showCopyToast('Nothing to copy.', 'error');
                return;
            }
            
            try {
                await clipboardWriteText(textToCopy);
                showCopyToast('All loaded content copied!', 'success');
                await markChapterAsRead();
            } catch (err) {
                showCopyToast('Clipboard unavailable.', 'error');
            }
        }
        
        // Mark the current chapter as fully read (100% progress)
        async function markChapterAsRead() {
            try {
                await fetch(`/api/chapter-progress/${encodeURIComponent(bookId)}/${currentPageIndex}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ progress: 100.0 })
                });
                
                // Update the progress bar in the sidebar
                const currentHref = document.querySelector('.toc-link.active')?.getAttribute('data-href');
                if (currentHref) {
                    const progressElem = document.querySelector(`.chapter-progress[data-href="${currentHref}"] .chapter-progress-fill`);
                    if (progressElem) {
                        progressElem.style.width = '100%';
                    }
                }
            } catch (error) {
                console.error('Failed to mark chapter as read:', error);
            }
        }
        
        // Show floating toolbar on text selection
        function showSelectionToolbar(x, y) {
            const toolbar = document.getElementById('selection-toolbar');
            if (!toolbar) return;
            
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (selectedText.length > 0) {
                const charCount = document.getElementById('selection-char-count');
                if (charCount) {
                    charCount.textContent = `${selectedText.length} chars`;
                }
                
                // Position toolbar above the selection
                toolbar.style.left = `${Math.max(10, Math.min(x - 100, window.innerWidth - 250))}px`;
                toolbar.style.top = `${Math.max(10, y - 50)}px`;
                toolbar.classList.add('visible');
            } else {
                hideSelectionToolbar();
            }
        }
        
        function hideSelectionToolbar() {
            const toolbar = document.getElementById('selection-toolbar');
            if (toolbar) {
                toolbar.classList.remove('visible');
            }
        }
        
        // Copy selected text
        async function copySelectedText() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                showCopyToast('No text selected.', 'error');
                return;
            }
            
            try {
                await clipboardWriteText(selectedText);
                showCopyToast('Selection copied!', 'success');
                hideSelectionToolbar();
            } catch (err) {
                showCopyToast('Clipboard unavailable.', 'error');
            }
        }
        
        // Add selection to batch clipboard
        function appendToClipboard() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                showCopyToast('No text selected.', 'error');
                return;
            }
            
            batchClipboard.push(selectedText);
            updateBatchButton();
            showCopyToast(`Added to batch (${batchClipboard.length} items)`, 'info');
            hideSelectionToolbar();
            
            // Clear the selection
            selection.removeAllRanges();
        }
        
        function clearSelection() {
            const selection = window.getSelection();
            selection.removeAllRanges();
            hideSelectionToolbar();
        }
        
        function updateBatchButton() {
            const batchBtn = document.getElementById('batch-clipboard-btn');
            const batchCount = document.getElementById('batch-count');
            
            if (batchBtn && batchCount) {
                batchCount.textContent = batchClipboard.length;
                batchBtn.style.display = batchClipboard.length > 0 ? 'inline-block' : 'none';
            }
        }
        
        // Show batch clipboard modal
        async function showBatchClipboard() {
            if (batchClipboard.length === 0) {
                showCopyToast('Batch clipboard is empty.', 'error');
                return;
            }
            
            const fullText = batchClipboard.join('\n\n---\n\n');
            
            // Simple confirm dialog to copy or clear
            const action = confirm(
                `Batch contains ${batchClipboard.length} items (${fullText.length} chars total).\n\n` +
                `OK = Copy all to clipboard\n` +
                `Cancel = Clear batch`
            );
            
            if (action) {
                try {
                    await clipboardWriteText(fullText);
                    showCopyToast(`Copied ${batchClipboard.length} items!`, 'success');
                } catch (err) {
                    showCopyToast('Clipboard unavailable.', 'error');
                }
            } else {
                batchClipboard = [];
                updateBatchButton();
                showCopyToast('Batch cleared.', 'info');
            }
        }
        
        // Mouse up handler for selection toolbar
        document.addEventListener('mouseup', function(e) {
            // Small delay to allow selection to complete
            setTimeout(() => {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                // For PDFs, always show toolbar on selection (text is always selectable)
                // For EPUBs, show toolbar when in selection mode or when text is selected
                if (selectedText.length > 0) {
                    showSelectionToolbar(e.clientX, e.clientY);
                } else {
                    hideSelectionToolbar();
                }
            }, 10);
        });
        
        // Hide toolbar when clicking outside
        document.addEventListener('mousedown', function(e) {
            const toolbar = document.getElementById('selection-toolbar');
            if (toolbar && !toolbar.contains(e.target)) {
                // Don't hide immediately - let the mouseup event handle it
            }
        });
        
        // Keyboard shortcut: Ctrl/Cmd + Shift + B to add to batch (avoids conflict with Ctrl/Cmd+B for bookmarks)
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'B') {
                e.preventDefault();
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                if (selectedText) {
                    appendToClipboard();
                }
            }
        });
        
        {% if is_pdf %}
        // Infinite scroll setup for PDFs
        function loadMorePages() {
            if (loadingPages || currentPageIndex >= totalPages - 1) {
                return;
            }
            
            loadingPages = true;
            const nextStart = currentPageIndex + 1;
            
            fetch(`/read/${bookId}/pages/${nextStart}/10`)
                .then(resp => resp.json())
                .then(data => {
                    if (data.pages && data.pages.length > 0) {
                        const contentDiv = document.getElementById('book-content');
                        data.pages.forEach(page => {
                            const pageWrapper = document.createElement('div');
                            pageWrapper.className = 'pdf-page';
                            pageWrapper.dataset.pageIndex = page.index;
                            
                            pageWrapper.innerHTML = `
                                <div class="pdf-page-header">
                                    <input type="checkbox" class="pdf-page-select" data-page-index="${page.index}" onchange="updatePdfPageSelection(this)" title="Select page for multi-copy">
                                    <span class="pdf-page-number">${page.title}</span>
                                    <div class="pdf-page-actions">
                                        <button class="pdf-copy-image-btn" onclick="copyPageImage(this, ${page.index})" title="Copy page as image to clipboard">
                                            <i class="fa-regular fa-image"></i> Copy Image
                                        </button>
                                        <button class="pdf-copy-image-btn" onclick="copyPageText(this, ${page.index})" title="Copy page text to clipboard">
                                            <i class="fa-regular fa-copy"></i> Copy Text
                                        </button>
                                    </div>
                                </div>
                                ${page.content}
                            `;
                            contentDiv.appendChild(pageWrapper);
                        });
                        
                        currentPageIndex = Math.max(...data.pages.map(p => p.index));
                        updatePageIndicator();
                        updateProgressBar();
                    }
                    loadingPages = false;
                })
                .catch(err => {
                    console.error('Failed to load pages:', err);
                    loadingPages = false;
                });
        }
        
        function updatePageIndicator() {
            const indicator = document.getElementById('page-count');
            if (indicator) {
                indicator.textContent = `Page ${currentPageIndex + 1} of ${totalPages}`;
            }
            
            // Update load all button state
            const loadAllBtn = document.getElementById('load-all-btn');
            if (loadAllBtn && currentPageIndex >= totalPages - 1) {
                loadAllBtn.innerHTML = '<i class="fa-solid fa-check"></i> All Pages Loaded';
                loadAllBtn.disabled = true;
            }
        }
        
        // Track scroll position to show current page
        function trackVisiblePage() {
            const pages = document.querySelectorAll('.pdf-page');
            const mainContent = document.getElementById('main');
            const scrollTop = mainContent.scrollTop;
            const viewportHeight = mainContent.clientHeight;
            
            let currentVisible = currentPageIndex + 1;
            
            pages.forEach(page => {
                const rect = page.getBoundingClientRect();
                const pageIndex = parseInt(page.dataset.pageIndex) + 1;
                
                // If the page is mostly in view
                if (rect.top < viewportHeight / 2 && rect.bottom > viewportHeight / 2) {
                    currentVisible = pageIndex;
                }
            });
            
            showPageIndicator(currentVisible);
        }

        // Set up infinite scroll listener
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !loadingPages) {
                    loadMorePages();
                }
            });
        }, { rootMargin: '500px' });

        window.addEventListener('load', () => {
            const sentinel = document.createElement('div');
            sentinel.id = 'infinite-scroll-sentinel';
            sentinel.style.height = '1px';
            document.getElementById('book-content').parentElement.appendChild(sentinel);
            observer.observe(sentinel);
            
            // Initialize progress bar
            updateProgressBar();
            
            // Track scroll for page indicator and sticky toolbar
            let scrollTimeout;
            const pdfToolbar = document.querySelector('.content-toolbar.pdf-toolbar');
            document.getElementById('main').addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(trackVisiblePage, 100);
                
                // Add/remove stuck class for sticky toolbar shadow
                if (pdfToolbar) {
                    const mainEl = document.getElementById('main');
                    if (mainEl.scrollTop > 20) {
                        pdfToolbar.classList.add('stuck');
                    } else {
                        pdfToolbar.classList.remove('stuck');
                    }
                }
            });
        });
        
        // Keyboard shortcut: Enter to jump to page when input is focused
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.activeElement.id === 'page-jump-input') {
                jumpToPage();
            }
            // Escape to close page jump
            if (e.key === 'Escape') {
                const container = document.getElementById('page-jump-container');
                if (container) container.classList.remove('visible');
            }
        });
        {% endif %}        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ loop.index0 }},
            {% endfor %}
        };

        // Save sidebar scroll position before navigation
        function saveScrollPosition() {
            const sidebar = document.getElementById('sidebar');
            if (sidebar) {
                sessionStorage.setItem('sidebarScrollPos', sidebar.scrollTop);
            }
        }

        // Restore sidebar scroll position after page load
        function restoreScrollPosition() {
            const sidebar = document.getElementById('sidebar');
            if (sidebar) {
                const scrollPos = sessionStorage.getItem('sidebarScrollPos');
                if (scrollPos !== null) {
                    sidebar.scrollTop = parseInt(scrollPos, 10);
                }
            }
        }

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            // We strip the anchor to find the page index
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            // Try exact match first
            let idx = spineMap[cleanFile];
            
            // If not found, try matching just the basename (filename without path)
            if (idx === undefined) {
                const basename = cleanFile.split('/').pop();
                for (const key in spineMap) {
                    if (key.split('/').pop() === basename) {
                        idx = spineMap[key];
                        break;
                    }
                }
            }

            if (idx !== undefined) {
                saveScrollPosition();
                let url = "/read/" + encodeURIComponent(bookId) + "/" + idx;
                // Fade out current content for a smooth transition
                const content = document.querySelector('.content-container');
                if (content) {
                    content.classList.remove('fade-in');
                    content.classList.add('fade-out');
                    setTimeout(() => { window.location.href = url; }, 250);
                } else {
                    window.location.href = url;
                }
            } else {
                console.log("Could not find index for", filename, "tried:", cleanFile);
            }
        }

        async function copyChapterContent() {
            const contentEl = document.querySelector('.book-content');
            if (!contentEl) return;

            const textToCopy = contentEl.innerText.trim();
            if (!textToCopy) {
                showCopyToast('Nothing to copy.', 'error');
                return;
            }

            try {
                await clipboardWriteText(textToCopy);
                showCopyToast('Chapter copied to clipboard!', 'success');
            } catch (err) {
                console.error('Copy failed', err);
                showCopyToast('Clipboard unavailable.', 'error');
            }
        }

        function toggleSidebar() {
            const body = document.body;
            const toggleBtn = document.getElementById('sidebar-toggle');
            body.classList.toggle('sidebar-collapsed');
            const isCollapsed = body.classList.contains('sidebar-collapsed');
            if (toggleBtn) {
                toggleBtn.textContent = isCollapsed ? 'Show Chapters' : 'Hide Chapters';
                toggleBtn.setAttribute('aria-pressed', String(isCollapsed));
            }
        }

        // Scroll active chapter into view within the sidebar
        function scrollActiveChapterIntoView() {
            const activeLink = document.querySelector('a.toc-link.active');
            if (activeLink) {
                activeLink.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Restore scroll position when page loads
        window.addEventListener('load', function() {
            // First try to restore saved position
            restoreScrollPosition();
            // Then ensure active chapter is visible
            setTimeout(scrollActiveChapterIntoView, 100);
            
            // Load user data (bookmarks, highlights, progress)
            loadUserData();
            
            // Update reading progress bar on scroll
            updateReadingProgress();
            
            // Apply initial fade-in to content for a smooth entrance
            const contentContainer = document.querySelector('.content-container');
            if (contentContainer) {
                contentContainer.classList.add('fade-in');
                setTimeout(() => contentContainer.classList.remove('fade-in'), 350);
            }
        });

        // Save scroll position on navigation buttons (Previous/Next)
        document.addEventListener('DOMContentLoaded', function() {
            const navButtons = document.querySelectorAll('.nav-btn:not(.disabled)');
            navButtons.forEach(button => {
                button.addEventListener('click', saveScrollPosition);
            });
            
            // Add scroll listener for reading progress on #main element
            const mainEl = document.getElementById('main');
            if (mainEl) {
                mainEl.addEventListener('scroll', () => {
                    updateReadingProgress();
                    saveReadingProgress();
                });
            }
            
            // Enhanced keyboard navigation
            document.addEventListener('keydown', (e) => {
                // Don't trigger shortcuts when typing in inputs
                const isTyping = ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);
                
                if (e.key === 'Escape') {
                    closeSearch();
                    const panel = document.getElementById('bookmarks-panel');
                    if (panel) panel.classList.remove('visible');
                    hideKeyboardHelp();
                }
                
                // Show keyboard help on ?
                if (e.key === '?' && !isTyping) {
                    toggleKeyboardHelp();
                }
                
                // Arrow keys for chapter navigation (only when not typing)
                if (!isTyping && !isPDF) {
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        navigateChapter('prev');
                    }
                    if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        navigateChapter('next');
                    }
                }
                
                // Home/End to go to first/last chapter
                if (!isTyping && !isPDF) {
                    if (e.key === 'Home' && e.ctrlKey) {
                        e.preventDefault();
                        window.location.href = `/read/${bookId}/0`;
                    }
                    if (e.key === 'End' && e.ctrlKey) {
                        e.preventDefault();
                        window.location.href = `/read/${bookId}/${totalPages - 1}`;
                    }
                }
                
                // Ctrl/Cmd + F for search
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    e.preventDefault();
                    openSearch();
                }
                // Ctrl/Cmd + B for bookmarks
                if ((e.ctrlKey || e.metaKey) && e.key === 'b' && !isTyping) {
                    e.preventDefault();
                    toggleBookmarksPanel();
                }
                
                // S to toggle sidebar
                if (e.key === 's' && !isTyping && !e.ctrlKey && !e.metaKey) {
                    toggleSidebar();
                }
                
                // Space to scroll down (like in PDF readers)
                if (e.key === ' ' && !isTyping) {
                    e.preventDefault();
                    const mainEl = document.getElementById('main');
                    if (mainEl) {
                        mainEl.scrollBy({ top: mainEl.clientHeight * 0.8, behavior: 'smooth' });
                    }
                }
            });
            
            // Close search modal when clicking outside
            document.getElementById('search-modal').addEventListener('click', (e) => {
                if (e.target.id === 'search-modal') {
                    closeSearch();
                }
            });
            
            // Load chapter progress and reading times
            loadChapterProgress();
            calculateReadingTimes();
            
            // Check for search query parameter from library search
            const urlParams = new URLSearchParams(window.location.search);
            const searchQuery = urlParams.get('search');
            if (searchQuery) {
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    performSearchHighlight(decodeURIComponent(searchQuery));
                }, 500);
            }

            // Inject copy buttons next to headings in EPUB content
            if (!isPDF) {
                injectHeadingCopyButtons();
            }
        });
        
        // ===== HEADING COPY BUTTONS =====

        function injectHeadingCopyButtons() {
            const content = document.getElementById('book-content');
            if (!content) return;

            content.querySelectorAll('h1, h2, h3').forEach(heading => {
                // Skip if already has a copy button
                if (heading.querySelector('.heading-copy-btn')) return;

                const btn = document.createElement('button');
                btn.className = 'heading-copy-btn';
                btn.title = 'Copy this section';
                btn.innerHTML = '<i class="fa-regular fa-copy"></i>';
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const sectionText = getSectionText(heading);
                    if (!sectionText) {
                        showCopyToast('No content in this section', 'info');
                        return;
                    }
                    try {
                        await clipboardWriteText(sectionText);
                        btn.innerHTML = '<i class="fa-solid fa-check"></i>';
                        showCopyToast('Section copied!', 'success');
                        setTimeout(() => { btn.innerHTML = '<i class="fa-regular fa-copy"></i>'; }, 2000);
                    } catch (err) {
                        showCopyToast('Clipboard unavailable', 'error');
                    }
                });
                heading.style.position = 'relative';
                heading.appendChild(btn);
            });
        }

        // Get text from a heading until the next heading of equal or higher level
        function getSectionText(heading) {
            const level = parseInt(heading.tagName[1]); // 1, 2, or 3
            const parts = [heading.textContent.trim()];
            let el = heading.nextElementSibling;
            while (el) {
                const tag = el.tagName;
                // Stop at same-level or higher heading
                if (/^H[1-6]$/.test(tag) && parseInt(tag[1]) <= level) break;
                // Skip copy buttons
                if (!el.classList.contains('heading-copy-btn')) {
                    parts.push(el.innerText?.trim() || '');
                }
                el = el.nextElementSibling;
            }
            return parts.filter(Boolean).join('\n\n');
        }

        // ===== KEYBOARD NAVIGATION HELPERS =====
        
        function navigateChapter(direction) {
            const prevBtn = document.querySelector('.nav-btn[href*="' + (currentPageIndex - 1) + '"]');
            const nextBtn = document.querySelector('.nav-btn[href*="' + (currentPageIndex + 1) + '"]');
            
            if (direction === 'prev' && currentPageIndex > 0) {
                saveScrollPosition();
                window.location.href = `/read/${bookId}/${currentPageIndex - 1}`;
            } else if (direction === 'next' && currentPageIndex < totalPages - 1) {
                saveScrollPosition();
                window.location.href = `/read/${bookId}/${currentPageIndex + 1}`;
            }
        }
        
        function toggleKeyboardHelp() {
            const help = document.getElementById('keyboard-help');
            if (help) {
                help.classList.toggle('visible');
            }
        }
        
        function hideKeyboardHelp() {
            const help = document.getElementById('keyboard-help');
            if (help) {
                help.classList.remove('visible');
            }
        }
        
        // ===== CHAPTER PROGRESS TRACKING =====
        
        async function loadChapterProgress() {
            try {
                const response = await fetch(`/api/chapter-progress/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    applyChapterProgress(data.progress || {});
                }
            } catch (error) {
                console.error('Failed to load chapter progress:', error);
            }
        }
        
        function applyChapterProgress(progressData) {
            // Apply progress to each chapter in the sidebar
            Object.keys(spineMap).forEach(href => {
                const chapterIndex = spineMap[href];
                const progress = progressData[chapterIndex] || 0;
                
                // Find the progress bar for this chapter
                const progressElem = document.querySelector(`.chapter-progress[data-href="${href}"] .chapter-progress-fill`);
                if (progressElem) {
                    progressElem.style.width = `${progress}%`;
                }

                // Set percent text next to chapter title
                const percentEl = document.querySelector(`.toc-chapter-percent[data-href="${href}"]`);
                if (percentEl) {
                    percentEl.textContent = `${Math.round(progress)}%`;
                }

                // Mark as read if 90%+
                const link = document.querySelector(`.toc-link[data-href="${href}"]`);
                if (progress >= 90) {
                    if (link) link.classList.add('read');
                    if (link) link.classList.remove('unread');
                } else {
                    if (link) link.classList.remove('read');
                }

                // Mark unread chapters (0% progress) with subtle background
                if (progress === 0) {
                    if (link) link.classList.add('unread');
                } else {
                    if (link) link.classList.remove('unread');
                }
            });
        }
        
        // Save current chapter progress when leaving page
        window.addEventListener('beforeunload', () => {
            const progress = updateReadingProgress();
            // Use sendBeacon with FormData for reliable delivery on page unload
            const formData = new FormData();
            formData.append('progress', progress);
            
            // sendBeacon doesn't support JSON content-type easily, so we use a query param approach
            navigator.sendBeacon(
                `/api/chapter-progress/${encodeURIComponent(bookId)}/${currentPageIndex}?progress=${encodeURIComponent(progress)}`,
                ''
            );
        });
        
        // ===== ESTIMATED READING TIME =====
        
        function calculateReadingTimes() {
            // Average reading speed: ~200-250 words per minute
            const wordsPerMinute = 225;
            
            // Get word count for current chapter
            const content = document.getElementById('book-content');
            if (content) {
                const text = content.innerText || '';
                const wordCount = text.trim().split(/\s+/).length;
                const minutes = Math.ceil(wordCount / wordsPerMinute);
                
                // Update reading time for current chapter
                const currentHref = "{{ current_chapter.href }}";
                const timeElem = document.querySelector(`.chapter-progress[data-href="${currentHref}"] .chapter-reading-time`);
                if (timeElem) {
                    timeElem.textContent = formatReadingTime(minutes);
                }
            }
            
            // For other chapters, fetch estimates from server
            fetchAllReadingTimes();
        }
        
        async function fetchAllReadingTimes() {
            try {
                const response = await fetch(`/api/reading-times/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    applyReadingTimes(data.reading_times || {});
                }
            } catch (error) {
                // Silent fail - reading times are not critical
                console.error('Failed to fetch reading times:', error);
            }
        }
        
        function applyReadingTimes(timesData) {
            // timesData is keyed by chapter href
            Object.keys(timesData).forEach(href => {
                const timeInfo = timesData[href];
                if (timeInfo && timeInfo.formatted) {
                    const timeElem = document.querySelector(`.chapter-progress[data-href="${href}"] .chapter-reading-time`);
                    if (timeElem) {
                        timeElem.textContent = timeInfo.formatted;
                        timeElem.title = `${timeInfo.word_count.toLocaleString()} words`;
                    }
                }
            });
        }
        
        function formatReadingTime(minutes) {
            if (minutes < 1) return '<1 min';
            if (minutes < 60) return `~${minutes} min`;
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return mins > 0 ? `~${hours}h ${mins}m` : `~${hours}h`;
        }
        
        // ===== READING SESSIONS =====
        
        async function startReadingSession() {
            sessionStartTime = Date.now();
            try {
                const response = await fetch('/api/sessions/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        book_id: bookId,
                        book_title: "{{ book.metadata.title | replace('\"', '\\\"') }}",
                        chapter_index: currentPageIndex,
                        chapter_title: "{{ current_chapter.title | replace('\"', '\\\"') }}"
                    })
                });
                if (response.ok) {
                    const data = await response.json();
                    currentSessionId = data.session_id;
                }
            } catch (error) {
                console.error('Failed to start reading session:', error);
            }
        }
        
        async function endReadingSession() {
            if (!currentSessionId || !sessionStartTime) return;
            
            const duration = Math.floor((Date.now() - sessionStartTime) / 1000);
            const scrollPos = document.getElementById('main')?.scrollTop / 
                             document.getElementById('main')?.scrollHeight || 0;
            
            try {
                await fetch(`/api/sessions/${currentSessionId}/end`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        duration_seconds: duration,
                        pages_read: isPDF ? 1 : 0,
                        scroll_position: scrollPos
                    })
                });
            } catch (error) {
                console.error('Failed to end reading session:', error);
            }
        }
        
        // End session before page unload
        window.addEventListener('beforeunload', () => {
            if (currentSessionId && sessionStartTime) {
                const duration = Math.floor((Date.now() - sessionStartTime) / 1000);
                navigator.sendBeacon(
                    `/api/sessions/${currentSessionId}/end`,
                    JSON.stringify({
                        duration_seconds: duration,
                        pages_read: isPDF ? 1 : 0,
                        scroll_position: 0
                    })
                );
            }
        });
        
        function toggleSessionPanel() {
            const panel = document.getElementById('session-history-panel');
            if (panel) {
                panel.classList.toggle('visible');
                if (panel.classList.contains('visible')) {
                    loadSessionStats();
                }
            }
        }
        
        async function loadSessionStats() {
            try {
                const response = await fetch('/api/sessions/stats');
                if (response.ok) {
                    const stats = await response.json();
                    
                    // Format total time
                    const totalHours = Math.floor(stats.total_time_seconds / 3600);
                    const totalMins = Math.floor((stats.total_time_seconds % 3600) / 60);
                    document.getElementById('stat-total-time').textContent = 
                        totalHours > 0 ? `${totalHours}h ${totalMins}m` : `${totalMins}m`;
                    
                    document.getElementById('stat-streak').textContent = stats.streak_days;
                    document.getElementById('stat-sessions').textContent = stats.session_count;
                    document.getElementById('stat-pages').textContent = stats.total_pages;
                }
            } catch (error) {
                console.error('Failed to load session stats:', error);
            }
        }
        
        function renderSessionList() {
            const list = document.getElementById('session-list');
            if (!list) return;
            
            if (readingSessions.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i class="fa-solid fa-clock-rotate-left" style="font-size: 2em; color: #ccc;"></i></div>
                        <div class="empty-state-text">No reading sessions yet</div>
                        <div class="empty-state-hint">Your reading history will appear here</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = readingSessions.slice(0, 20).map(s => {
                const duration = s.duration_seconds || 0;
                const mins = Math.floor(duration / 60);
                const date = new Date(s.start_time).toLocaleDateString();
                const time = new Date(s.start_time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                
                return `
                    <div class="session-item">
                        <div class="session-book">${escapeHtml(s.book_title || 'Unknown Book')}</div>
                        <div class="session-chapter">${escapeHtml(s.chapter_title || 'Chapter ' + (s.chapter_index + 1))}</div>
                        <div class="session-time">
                            <span>${date} at ${time}</span>
                            <span>${mins > 0 ? mins + ' min' : '<1 min'}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // ===== DICTIONARY & VOCABULARY =====
        
        // Double-click handler for dictionary lookup
        document.addEventListener('dblclick', async function(e) {
            const selection = window.getSelection();
            const word = selection.toString().trim();
            
            // Only trigger for single words (no spaces)
            if (word && !word.includes(' ') && word.length > 1 && word.length < 30) {
                await lookupWord(word, e.clientX, e.clientY);
            }
        });
        
        async function lookupWord(word, x, y) {
            const popup = document.getElementById('dictionary-popup');
            const wordEl = document.getElementById('dict-word');
            const phoneticEl = document.getElementById('dict-phonetic');
            const contentEl = document.getElementById('dict-content');
            
            // Show popup with loading state
            wordEl.textContent = word;
            phoneticEl.textContent = '';
            contentEl.innerHTML = '<div class="dict-loading">Looking up definition...</div>';
            
            // Show centered popup (CSS handles positioning)
            popup.classList.add('visible');
            
            try {
                // Use Free Dictionary API
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word)}`);
                
                if (!response.ok) {
                    contentEl.innerHTML = `
                        <div class="dict-error">
                            <p>No definition found for "${escapeHtml(word)}"</p>
                            <p style="font-size: 0.85em; color: #888; margin-top: 10px;">Try a different word</p>
                        </div>
                    `;
                    return;
                }
                
                const data = await response.json();
                const entry = data[0];
                
                // Update phonetic
                if (entry.phonetic) {
                    phoneticEl.textContent = entry.phonetic;
                }
                
                // Build definition HTML
                let html = '';
                
                entry.meanings.forEach(meaning => {
                    html += `<div class="dict-part-of-speech">${meaning.partOfSpeech}</div>`;
                    
                    meaning.definitions.slice(0, 2).forEach(def => {
                        html += `<div class="dict-definition">${escapeHtml(def.definition)}</div>`;
                        if (def.example) {
                            html += `<div class="dict-example">"${escapeHtml(def.example)}"</div>`;
                        }
                    });
                });
                
                // Get context (sentence containing the word)
                const context = getWordContext(word);
                
                html += `
                    <div class="dict-actions">
                        <button class="dict-btn dict-btn-primary" onclick="saveToVocabulary('${escapeHtml(word)}', ${JSON.stringify(entry).replace(/'/g, "\\'")}, '${escapeHtml(context)}')">
                            <i class="fa-solid fa-plus"></i> Save to Vocabulary
                        </button>
                        <button class="dict-btn dict-btn-secondary" onclick="closeDictionary()">
                            Close
                        </button>
                    </div>
                `;
                
                contentEl.innerHTML = html;
            } catch (error) {
                console.error('Dictionary lookup failed:', error);
                contentEl.innerHTML = `
                    <div class="dict-error">
                        <p>Failed to look up "${escapeHtml(word)}"</p>
                        <p style="font-size: 0.85em; color: #888; margin-top: 10px;">Check your internet connection</p>
                    </div>
                `;
            }
        }
        
        function getWordContext(word) {
            // Try to find the sentence containing the word
            const content = document.getElementById('book-content');
            if (!content) return '';
            
            const text = content.innerText || '';
            const sentences = text.split(/[.!?]+/);
            
            for (const sentence of sentences) {
                if (sentence.toLowerCase().includes(word.toLowerCase())) {
                    return sentence.trim().substring(0, 200);
                }
            }
            return '';
        }
        
        function closeDictionary() {
            const popup = document.getElementById('dictionary-popup');
            if (popup) {
                popup.classList.remove('visible');
            }
        }
        
        async function saveToVocabulary(word, entryData, context) {
            const entry = typeof entryData === 'string' ? JSON.parse(entryData) : entryData;
            
            // Extract first definition and example
            let definition = '';
            let partOfSpeech = '';
            let example = '';
            
            if (entry.meanings && entry.meanings.length > 0) {
                partOfSpeech = entry.meanings[0].partOfSpeech || '';
                if (entry.meanings[0].definitions && entry.meanings[0].definitions.length > 0) {
                    definition = entry.meanings[0].definitions[0].definition || '';
                    example = entry.meanings[0].definitions[0].example || '';
                }
            }
            
            try {
                const response = await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        word: word,
                        definition: definition,
                        phonetic: entry.phonetic || '',
                        part_of_speech: partOfSpeech,
                        example: example,
                        chapter_index: currentPageIndex,
                        context: context
                    })
                });
                
                if (response.ok) {
                    showToast('Word saved to vocabulary!');
                    closeDictionary();
                    
                    // Reload vocabulary
                    const vocabRes = await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}`);
                    if (vocabRes.ok) {
                        const vocabData = await vocabRes.json();
                        userVocabulary = vocabData.words || [];
                        renderVocabularyList();
                    }
                }
            } catch (error) {
                console.error('Failed to save word:', error);
                showToast('Failed to save word', 'error');
            }
        }
        
        function toggleVocabularyPanel() {
            const panel = document.getElementById('vocabulary-panel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }
        
        function renderVocabularyList() {
            const list = document.getElementById('vocab-list');
            const stats = document.getElementById('vocab-stats');
            if (!list) return;
            
            if (userVocabulary.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i class="fa-solid fa-language" style="font-size: 2em; color: #ccc;"></i></div>
                        <div class="empty-state-text">No saved words yet</div>
                        <div class="empty-state-hint">Double-click any word to look it up and save it</div>
                    </div>
                `;
                if (stats) stats.innerHTML = '<strong>0</strong> words saved';
                return;
            }
            
            list.innerHTML = userVocabulary.map(w => `
                <div class="vocab-item">
                    <button class="vocab-delete" onclick="deleteVocabWord('${w.id}')" title="Delete"><i class="fa-regular fa-trash-can"></i></button>
                    <div>
                        <span class="vocab-word">${escapeHtml(w.word)}</span>
                        <span class="vocab-pos">${escapeHtml(w.part_of_speech || '')}</span>
                    </div>
                    <div class="vocab-def">${escapeHtml(w.definition)}</div>
                    ${w.context ? `<div class="vocab-context">"${escapeHtml(w.context.substring(0, 100))}..."</div>` : ''}
                    <div class="vocab-meta">Chapter ${w.chapter_index + 1} • ${new Date(w.created_at).toLocaleDateString()}</div>
                </div>
            `).join('');
            
            if (stats) stats.innerHTML = `<strong>${userVocabulary.length}</strong> words saved`;
        }
        
        function filterVocabulary() {
            const query = document.getElementById('vocab-search').value.toLowerCase();
            const items = document.querySelectorAll('.vocab-item');
            
            items.forEach(item => {
                const word = item.querySelector('.vocab-word')?.textContent.toLowerCase() || '';
                const def = item.querySelector('.vocab-def')?.textContent.toLowerCase() || '';
                item.style.display = (word.includes(query) || def.includes(query)) ? 'block' : 'none';
            });
        }
        
        async function deleteVocabWord(wordId) {
            try {
                await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}/${wordId}`, {
                    method: 'DELETE'
                });
                userVocabulary = userVocabulary.filter(w => w.id !== wordId);
                renderVocabularyList();
                showToast('Word removed');
            } catch (error) {
                console.error('Failed to delete word:', error);
            }
        }
        
        // ===== ANNOTATIONS =====
        
        function toggleAnnotationsPanel() {
            const panel = document.getElementById('annotations-panel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }
        
        function renderAnnotationsList(filter = 'all') {
            const list = document.getElementById('annot-list');
            if (!list) return;
            
            let annotations = userAnnotations;
            
            // Apply filter
            if (filter === 'chapter') {
                annotations = annotations.filter(a => a.chapter_index === currentPageIndex);
            }
            
            if (annotations.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><i class="fa-regular fa-note-sticky" style="font-size: 2em; color: #ccc;"></i></div>
                        <div class="empty-state-text">No annotations ${filter === 'chapter' ? 'in this chapter' : 'yet'}</div>
                        <div class="empty-state-hint">Add notes to your highlights and bookmarks</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = annotations.map(a => `
                <div class="annot-item">
                    <div class="annot-actions">
                        <button onclick="editAnnotation('${a.id}')" title="Edit"><i class="fa-regular fa-pen-to-square"></i></button>
                        <button onclick="deleteAnnotation('${a.id}')" title="Delete"><i class="fa-regular fa-trash-can"></i></button>
                    </div>
                    <div class="annot-chapter">Chapter ${a.chapter_index + 1}</div>
                    <div class="annot-text">${escapeHtml(a.note_text)}</div>
                    ${a.tags && a.tags.length > 0 ? `
                        <div class="annot-tags">
                            ${a.tags.map(tag => `<span class="annot-tag">#${escapeHtml(tag)}</span>`).join('')}
                        </div>
                    ` : ''}
                    <div class="annot-meta">${new Date(a.created_at).toLocaleDateString()}</div>
                </div>
            `).join('');
        }
        
        function showAnnotTab(tab) {
            const tabs = document.querySelectorAll('.annot-tab');
            tabs.forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            renderAnnotationsList(tab);
        }
        
        function filterAnnotations() {
            const query = document.getElementById('annot-search').value.toLowerCase();
            const items = document.querySelectorAll('.annot-item');
            
            items.forEach(item => {
                const text = item.querySelector('.annot-text')?.textContent.toLowerCase() || '';
                const tags = item.querySelector('.annot-tags')?.textContent.toLowerCase() || '';
                item.style.display = (text.includes(query) || tags.includes(query)) ? 'block' : 'none';
            });
        }
        
        function openAddNoteModal(highlightId = null, bookmarkId = null) {
            currentNoteContext = { highlightId, bookmarkId };
            document.getElementById('note-textarea').value = '';
            document.getElementById('note-tags-input').value = '';
            document.getElementById('add-note-modal').classList.add('visible');
            document.getElementById('note-textarea').focus();
        }
        
        function closeNoteModal() {
            document.getElementById('add-note-modal').classList.remove('visible');
            currentNoteContext = null;
        }
        
        async function saveNote() {
            const noteText = document.getElementById('note-textarea').value.trim();
            const tagsInput = document.getElementById('note-tags-input').value.trim();
            const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];
            
            if (!noteText) {
                showToast('Please enter a note', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/annotations/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: currentPageIndex,
                        note_text: noteText,
                        highlight_id: currentNoteContext?.highlightId,
                        bookmark_id: currentNoteContext?.bookmarkId,
                        tags: tags
                    })
                });
                
                if (response.ok) {
                    showToast('Note saved!');
                    closeNoteModal();
                    
                    // Reload annotations
                    const annotRes = await fetch(`/api/annotations/${encodeURIComponent(bookId)}`);
                    if (annotRes.ok) {
                        const annotData = await annotRes.json();
                        userAnnotations = annotData.annotations || [];
                        renderAnnotationsList();
                    }
                }
            } catch (error) {
                console.error('Failed to save note:', error);
                showToast('Failed to save note', 'error');
            }
        }
        
        async function deleteAnnotation(annotationId) {
            try {
                await fetch(`/api/annotations/${encodeURIComponent(bookId)}/${annotationId}`, {
                    method: 'DELETE'
                });
                userAnnotations = userAnnotations.filter(a => a.id !== annotationId);
                renderAnnotationsList();
                showToast('Annotation deleted');
            } catch (error) {
                console.error('Failed to delete annotation:', error);
            }
        }
        
        function editAnnotation(annotationId) {
            const annot = userAnnotations.find(a => a.id === annotationId);
            if (!annot) return;
            
            currentNoteContext = { annotationId };
            document.getElementById('note-textarea').value = annot.note_text;
            document.getElementById('note-tags-input').value = (annot.tags || []).join(', ');
            document.getElementById('add-note-modal').classList.add('visible');
            document.getElementById('note-textarea').focus();
        }
        
        async function exportAnnotations() {
            try {
                const response = await fetch(`/api/annotations/${encodeURIComponent(bookId)}/export?format=markdown`);
                if (response.ok) {
                    const content = await response.text();
                    const blob = new Blob([content], { type: 'text/markdown' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${bookId}_annotations.md`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showToast('Annotations exported!');
                }
            } catch (error) {
                console.error('Export failed:', error);
                showToast('Export failed', 'error');
            }
        }
        
        // Add "Add Note" button to selection toolbar
        function addNoteFromSelection() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                showToast('Select text first', 'error');
                return;
            }
            
            // Create a highlight first, then add note
            highlightSelection('yellow').then(() => {
                // Open note modal linked to the new highlight
                openAddNoteModal();
            });
        }

        // Multi-chapter copy functionality
        function updateCopyButton() {
            const checkboxes = document.querySelectorAll('.chapter-checkbox');
            const checkedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
            const copyBtn = document.getElementById('copy-chapters-btn');

            if (copyBtn) {
                copyBtn.textContent = `Copy Selected (${checkedCount})`;
                copyBtn.disabled = checkedCount === 0;
            }
        }

        function selectAllChapters() {
            const checkboxes = document.querySelectorAll('.chapter-checkbox');
            checkboxes.forEach(cb => cb.checked = true);
            updateCopyButton();
        }

        function clearChapterSelection() {
            const checkboxes = document.querySelectorAll('.chapter-checkbox');
            checkboxes.forEach(cb => cb.checked = false);
            updateCopyButton();
        }

        async function copySelectedChapters() {
            const checkboxes = document.querySelectorAll('.chapter-checkbox:checked');
            if (checkboxes.length === 0) {
                showToast('No chapters selected', 'error');
                return;
            }

            const copyBtn = document.getElementById('copy-chapters-btn');
            const originalText = copyBtn.textContent;
            const selectedHrefs = Array.from(checkboxes).map(cb => cb.getAttribute('data-href'));
            
            copyBtn.disabled = true;

            try {
                // Show progress indicator
                let progressCount = 0;
                const totalCount = selectedHrefs.length;
                
                // Fetch chapter text content from backend
                copyBtn.textContent = `Fetching chapters... (0/${totalCount})`;
                
                const response = await fetch('/api/chapters/text', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        book_id: '{{ book_id }}',
                        chapter_hrefs: selectedHrefs
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch chapters');
                }

                const data = await response.json();
                const chapters = data.chapters;

                // Update progress: fetching complete
                copyBtn.textContent = 'Copying to clipboard...';

                // Combine chapter text with separators
                const combinedText = chapters.map(ch => {
                    return `=== ${ch.title} ===\n\n${ch.text}`;
                }).join('\n\n---\n\n');

                // Copy to clipboard
                await clipboardWriteText(combinedText);

                // Mark selected chapters as read
                copyBtn.textContent = `Marking chapters as read... (0/${chapters.length})`;
                for (let i = 0; i < chapters.length; i++) {
                    const chapter = chapters[i];
                    const spineIndex = Object.keys(spineMap).findIndex(
                        key => key.endsWith(chapter.href.split('/').pop())
                    );
                    
                    if (spineIndex !== -1) {
                        await fetch(
                            `/api/chapter-progress/${encodeURIComponent(bookId)}/${spineIndex}`,
                            {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ progress: 100.0 })
                            }
                        );
                        
                        // Update progress bar for this chapter
                        const link = document.querySelector(
                            `.toc-link[data-href="${chapter.href}"]`
                        );
                        if (link) {
                            link.classList.add('read');
                            const progressBar = link.parentElement.querySelector(
                                '.chapter-progress-fill'
                            );
                            if (progressBar) {
                                progressBar.style.width = '100%';
                            }
                        }
                    }
                    
                    // Update progress display
                    copyBtn.textContent = `Marking chapters as read... (${i + 1}/${chapters.length})`;
                }

                showToast(`Copied and marked ${chapters.length} chapter${chapters.length > 1 ? 's' : ''} as read!`, 'success');

                // Clear selection after successful copy
                clearChapterSelection();

            } catch (error) {
                console.error('Error copying chapters:', error);
                showToast('Failed to copy chapters', 'error');
            } finally {
                copyBtn.textContent = originalText;
                copyBtn.disabled = false;
            }
        }

        function filterChapters(filterType) {
            const checkboxes = document.querySelectorAll('.chapter-checkbox');
            const searchTerm = document.getElementById('chapter-search')?.value.toLowerCase() || '';

            checkboxes.forEach(cb => {
                const chapterItem = cb.closest('.toc-item');
                if (!chapterItem) return;

                const title = chapterItem.textContent.toLowerCase();
                const matchesSearch = !searchTerm || title.includes(searchTerm);
                
                let matchesFilter = true;
                if (filterType !== 'all') {
                    const link = chapterItem.querySelector('.toc-link');
                    const isRead = link?.classList.contains('read') || false;
                    
                    if (filterType === 'unread') {
                        matchesFilter = !isRead;
                    } else if (filterType === 'read') {
                        matchesFilter = isRead;
                    }
                }

                const shouldShow = matchesSearch && matchesFilter;
                chapterItem.style.display = shouldShow ? '' : 'none';

                // If hiding, uncheck the checkbox
                if (!shouldShow) {
                    cb.checked = false;
                }
            });

            updateCopyButton();
        }

        // Reset filter when chapter progress is updated
        function resetChapterFilter() {
            const filterSelect = document.getElementById('chapter-filter');
            const searchInput = document.getElementById('chapter-search');
            if (filterSelect) filterSelect.value = 'all';
            if (searchInput) searchInput.value = '';
            filterChapters('all');
        }
    </script>
</body>
</html>
